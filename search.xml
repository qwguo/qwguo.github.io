<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>瀑布流布局实现的多种方法</title>
      <link href="/2020/06/26/CSS/%E7%80%91%E5%B8%83%E6%B5%81%E5%B8%83%E5%B1%80%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2020/06/26/CSS/%E7%80%91%E5%B8%83%E6%B5%81%E5%B8%83%E5%B1%80%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="瀑布流布局实现的多种方法"><a href="#瀑布流布局实现的多种方法" class="headerlink" title="瀑布流布局实现的多种方法"></a>瀑布流布局实现的多种方法</h1><blockquote><p>瀑布流布局看上去属于多列布局的一种，每列宽度相等但是高度不固定，从而形成的类似于砌墙效果。</p></blockquote><h2 id="基础布局介绍"><a href="#基础布局介绍" class="headerlink" title="基础布局介绍"></a>基础布局介绍</h2><h3 id="多列瀑布流布局"><a href="#多列瀑布流布局" class="headerlink" title="多列瀑布流布局"></a>多列瀑布流布局</h3><blockquote><p>通过创建相同宽度的多个列然后通过计算哪一列最低然后给列中添加元素来实现。</p></blockquote><p><strong>代码：</strong></p><pre><code class="html">&lt;div class=&quot;falls-1&quot; id=&quot;falls_1&quot;&gt;  &lt;div class=&quot;columns&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;columns&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;columns&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;columns&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">/*  这里我们通过inline-block来布局 */.falls-1  {  letter-spacing: -.35em;}/* 设置4列，每列占25%宽度 */.falls-1 .columns {  letter-spacing: normal;  width: 25%;  display: inline-block;  vertical-align: top;}.falls-1 .columns div{  background-color: orange;  margin: 0 10px 10px;  padding: 10px;  font-size: 40px;  color:white;}</code></pre><pre><code class="javascript">var listArray = [];// 这里我们随机生成100个高度在50-400之间的数据for (var i = 0; i &lt; 100; i++) {  listArray.push(parseInt(Math.random() * (400 - 50 + 1) + 50, 10));}var falls_1 = document.getElementById(&#39;falls_1&#39;);var columns = falls_1.children;// 循环数据数组for(var x = 0; x&lt;listArray.length; x++){  var curColumns = columns[0];  var item = document.createElement(&#39;div&#39;);  item.style.height = listArray[x] + &#39;px&#39;;  item.innerText = x;  // 通过判断哪一列最低然后获取最低的列  for(var y = 1; y&lt;columns.length; y++){    if(curColumns.clientHeight&gt;columns[y].clientHeight){      curColumns = columns[y];    }  }  // 把元素添加的最低的列  curColumns.appendChild(item);}</code></pre><p><strong>示例：</strong><a href="https://codepen.io/qwguo88/pen/WNrEyzZ" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/WNrEyzZ</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="falls-more-columns" src="https://codepen.io/qwguo88/embed/WNrEyzZ?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/WNrEyzZ" rel="external nofollow noopener noreferrer" target="_blank">falls-more-columns</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h3 id="相对定位和绝对定位结合实现"><a href="#相对定位和绝对定位结合实现" class="headerlink" title="相对定位和绝对定位结合实现"></a>相对定位和绝对定位结合实现</h3><blockquote><p>通过元素的绝对定位来实现瀑布流相对来说比多列布局要复杂以下，因为他没有列得概念所以需要记录比较低的那一项然后按照这一项来设置要添加的新项的位置，具体代码如下：</p></blockquote><p><strong>代码：</strong></p><pre><code class="html">&lt;div class=&quot;falls-2&quot; id=&quot;falls_2&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="css">/*  这里我们通过inline-block来布局 */.falls-2  {  position: relative;}/* 这里我们给元素设置宽度为25%，也就是按照四列来设置 */.falls-2 .item{  width: 25%;  position: absolute;}/* 为了计算方便我们把所有的间距都在内部的元素中设置，这样一来我们就不用再计算定位的时候在去额外计算内外间距的距离了 */.falls-2 .item-inner{  position: absolute;  background-color: orange;  top: 0;  bottom: 10px;  right: 10px;  left: 10px;  padding: 10px;  font-size: 40px;  color:white;}</code></pre><pre><code class="javascript">// 随机生成100条数据var listArray = [];for (var i = 0; i &lt; 100; i++) {  listArray.push(parseInt(Math.random() * (400 - 80 + 1) + 80, 10));}// 这里表示列数var colLength = 4;var falls_1 = document.getElementById(&#39;falls_2&#39;);var colArray = [];// 通过父级的宽度和设置的列数来计算出每一项的宽度var itemW = falls_1.clientWidth/colLength;// 循环列数，初始化第一次元素的初始位置for(var x = 0; x&lt;colLength;x++){  colArray.push({t: 0, l: x*itemW});}// 循环数据for(var x = 0; x&lt;listArray.length; x++){  // 取第一个初始化数据  var curPosition = colArray[0];  // 然后通过循环判断哪一个数据最低  for(var y = 1; y&lt;colArray.length; y++){    if(curPosition.t &gt; colArray[y].t){      curPosition = colArray[y];    }  }  // 创建元素，并且给元素设置位置信息和宽高等信息  var item = document.createElement(&#39;div&#39;);  var itemInner = document.createElement(&#39;div&#39;);  item.setAttribute(&#39;class&#39;,&#39;item&#39;);  itemInner.setAttribute(&#39;class&#39;,&#39;item-inner&#39;);  item.style.height = listArray[x] + &#39;px&#39;;  item.style.top = curPosition.t + &#39;px&#39;;  item.style.left = curPosition.l + &#39;px&#39;;  item.style.width = itemW + &#39;px&#39;;  itemInner.innerText = x;  item.appendChild(itemInner);  falls_1.appendChild(item);  // 然后更新初始化中的数据，使下次循环时记录  curPosition.t = curPosition.t + listArray[x];}</code></pre><p><strong>示例：</strong><a href="https://codepen.io/qwguo88/pen/KKVvBWb" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/KKVvBWb</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="falls-absolute" src="https://codepen.io/qwguo88/embed/KKVvBWb?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/KKVvBWb" rel="external nofollow noopener noreferrer" target="_blank">falls-absolute</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h3 id="纯css实现瀑布流布局–columns"><a href="#纯css实现瀑布流布局–columns" class="headerlink" title="纯css实现瀑布流布局–columns"></a>纯css实现瀑布流布局–columns</h3><blockquote><p>上边的两种方式都是css结合js来实现的，我们也可使只使用css就能实现瀑布流布局，<code>columns</code>是css中用来实现多列布局的属性，它可以把元素中的内容以相同宽度分成多列来呈现，我们可以通过此特性来实现瀑布流效果。</p></blockquote><pre><code class="html">&lt;div class=&quot;falls-3&quot; id=&quot;falls_3&quot;&gt;  &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;  &lt;!-- 这里省略重复多个 --&gt;  ...&lt;/div&gt;</code></pre><pre><code class="css">.falls-3{  column-count: 4;  column-width: 25%;  column-span: 10px;  padding-top: 10px;}.item{  background-color: orange;  margin: 0 0 10px;  padding: 10px;  font-size: 40px;  color:white;  break-inside: avoid;  border-radius: 10px;}</code></pre><p><strong>示例：</strong><a href="https://codepen.io/qwguo88/pen/oNbGNXj" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/oNbGNXj</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="falls-columns" src="https://codepen.io/qwguo88/embed/oNbGNXj?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/oNbGNXj" rel="external nofollow noopener noreferrer" target="_blank">falls-columns</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p>我们看到上边的代码发现，column实现瀑布流布局非常简单，几行简单的代码就实现了瀑布流布局效果，但是查看输出结果发现这种布局是一列一列的渲染，它是浏览器内部先通过项目的总是计算出每一列放多少内容，然后在一列一列的填充，然后通过项目的break-inside:avoid来实现内部的行不在项的中间断列，这种结果并不是我们在开发中真正想要的效果</p><h2 id="实际开发中的应用"><a href="#实际开发中的应用" class="headerlink" title="实际开发中的应用"></a>实际开发中的应用</h2><blockquote><p>在上边的案例中我们只是介绍的在列数固定的情况下并且项目元素为固定高度的情况下实现步骤，但是我们在真正的开发中往往要比这个结构复杂，比如有图片需要等待图片加载完毕后再计算高度，有文字并且文字内容不固定。和现在流行的框架vue，微信小程序等都是通过数据渲染的。接下来我们将介绍各种的实现方法。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>页面布局之两列布局的n种方法</title>
      <link href="/2020/06/24/CSS/%E4%B8%A4%E5%88%97%E5%B8%83%E5%B1%80%E7%9A%84n%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2020/06/24/CSS/%E4%B8%A4%E5%88%97%E5%B8%83%E5%B1%80%E7%9A%84n%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="页面布局之两列布局的n种方法"><a href="#页面布局之两列布局的n种方法" class="headerlink" title="页面布局之两列布局的n种方法"></a>页面布局之两列布局的n种方法</h1><h2 id="两列布局之表格布局"><a href="#两列布局之表格布局" class="headerlink" title="两列布局之表格布局"></a>两列布局之表格布局</h2><blockquote><p>说起表格布局是在css3之前兼容性最好的一种布局方式，使用表格做两列自适应宽度或者高度布局能够在ie6浏览器中得到很好的兼容。</p></blockquote><p><strong>示例：</strong><br>查看案例：<a href="https://codepen.io/qwguo88/full/pogwJRK" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/pogwJRK</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="two-columns-layout-table" src="https://codepen.io/qwguo88/embed/pogwJRK?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/pogwJRK" rel="external nofollow noopener noreferrer" target="_blank">two-columns-layout-table</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p>从上边的案例中可以看到通过使用表格能够轻松实现左右列高度一样的效果，而不用担心左右内容不同意的问题。优点：自适应强，兼容性好；缺点html结构代码量多。</p><h2 id="两列布局之浮动布局"><a href="#两列布局之浮动布局" class="headerlink" title="两列布局之浮动布局"></a>两列布局之浮动布局</h2><blockquote><p>浮动布局是继表格布局后比较常用的一种布局方式，它通过给元素设置左右浮动实现。</p></blockquote><p><strong>示例：</strong><br>查看案例： <a href="https://codepen.io/qwguo88/pen/eYJRNXq" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/eYJRNXq</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="two-columns-layout-float" src="https://codepen.io/qwguo88/embed/eYJRNXq?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/eYJRNXq" rel="external nofollow noopener noreferrer" target="_blank">two-columns-layout-float</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p>通过上边的各种案例可以看出，浮动布局在html结构代码上比表格精简了很多，但是要想实现一些特殊效果还需要些通过不同方式实现，同时还需要解决由浮动带来的各种问题</p><ol><li>比如浮动后父级高度不能自适应内容高度，需要给父级设置overflow来触发父级的BFC，或者给父级设置伪类，或者添加空div清除浮动方式来解决高度塌陷问题。</li><li>不能做到两列高度统一，也需要借助其他方式解决，给一个列添加外部div并且设置和另一列一样的背景颜色来在视觉上达到一样高度的效果。</li></ol><p>浮动布局的优点：结构代码量少，代码看上区可读性强；缺点：需要解决由浮动带来的一系列问题，无法实现真正意义上的左右高度一样效果。</p><h2 id="两列布局之行内块元素"><a href="#两列布局之行内块元素" class="headerlink" title="两列布局之行内块元素"></a>两列布局之行内块元素</h2><p><strong>示例：</strong><br>查看案例：<a href="https://codepen.io/qwguo88/pen/wvMeMGB" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/wvMeMGB</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="two-columns-layout-inline-block" src="https://codepen.io/qwguo88/embed/wvMeMGB?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/wvMeMGB" rel="external nofollow noopener noreferrer" target="_blank">two-columns-layout-inline-block</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p>行内块元素布局优点：<br>它能够解决浮动布局带来的问题，</p><ol><li>两列高度不一样的问题（前提必须给父级设置高度）；</li><li>不存在父级高度塌陷问题。<br>缺点：</li><li>不能做一列固定另一列自适应宽度，</li><li>只能设置百分比宽度做到两列宽度自适应；</li><li>由于浏览器对代码中的空格渲染站位问题，需要代码不能有换行空格，或者通过其他方式处理如：font-size:0;letter-spacing: -.35em;</li></ol><h2 id="两列布局之定位布局"><a href="#两列布局之定位布局" class="headerlink" title="两列布局之定位布局"></a>两列布局之定位布局</h2><blockquote><p>两列定位布局通常为父级设置相对定位，一列设置绝对定位固定宽度或者百分比宽度，然后按照父级靠左或者靠右定位，然后另一列设置间距来空出定位列的位置</p></blockquote><p><strong>示例：</strong><br>查看案例：<a href="https://codepen.io/qwguo88/pen/BajZwWR" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/BajZwWR</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="two-columns-layout-position" src="https://codepen.io/qwguo88/embed/BajZwWR?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/BajZwWR" rel="external nofollow noopener noreferrer" target="_blank">two-columns-layout-position</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p>定位布局的优点：</p><ol><li>它可是使比较低的列能够自适应比较高的列的高度（前提需要低的列绝对定位然后设置100%高度或者上下位置为0）<br>缺点：</li><li>当非定位列不够高还是撑不开父元素高度，导致后边的内容上移也就是父级高度塌陷。</li></ol><h2 id="两列布局之多列布局columns属性"><a href="#两列布局之多列布局columns属性" class="headerlink" title="两列布局之多列布局columns属性"></a>两列布局之多列布局columns属性</h2><blockquote><p>严格意义上讲columns使用来实现文字类似于报纸一样的排版效果，但是他也能用来布局页面</p></blockquote><p><strong>示例：</strong><br>查看案例：<a href="https://codepen.io/qwguo88/pen/RwrgyMz" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/RwrgyMz</a></p><iframe height="300" style="width: 100%;" scrolling="no" title="two-columns-layout-columns" src="https://codepen.io/qwguo88/embed/RwrgyMz?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/RwrgyMz" rel="external nofollow noopener noreferrer" target="_blank">two-columns-layout-columns</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p>从上边案例可以看出，columns更适合多列等宽布局，并且是那种层次不齐的瀑布流效果。它并不能为单独列设置单一宽度</p><h2 id="两列布局之弹性盒模型布局"><a href="#两列布局之弹性盒模型布局" class="headerlink" title="两列布局之弹性盒模型布局"></a>两列布局之弹性盒模型布局</h2><blockquote><p>css3中的<code>flex</code>弹性盒模型布局的出现弥补了上边所介绍的布局的不足之处</p></blockquote><p><strong>示例：</strong><br>查看案例：<a href="https://codepen.io/qwguo88/pen/KKVqQwy" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/KKVqQwy</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="two-columns-layout-flex" src="https://codepen.io/qwguo88/embed/KKVqQwy?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/KKVqQwy" rel="external nofollow noopener noreferrer" target="_blank">two-columns-layout-flex</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="两列布局之网格布局"><a href="#两列布局之网格布局" class="headerlink" title="两列布局之网格布局"></a>两列布局之网格布局</h2><blockquote><p>css3中的<code>grid</code>网格布局是更加灵活的一种布局模式，用网格布局实现两列布局更加方便</p></blockquote><p><strong>示例：</strong><br>查看案例：<a href="https://codepen.io/qwguo88/pen/ZEQyjzN" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/ZEQyjzN</a></p><iframe height="300" style="width: 100%;" scrolling="no" title="two-columns-layout-grid" src="https://codepen.io/qwguo88/embed/ZEQyjzN?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/ZEQyjzN" rel="external nofollow noopener noreferrer" target="_blank">two-columns-layout-grid</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p>上边案例可以看到，使用网格布局实现两列布局最简单的方法就是直接给父级设置样式就能实现，而且还可以轻松实现高度统一。通过使用网格可以用多种方式实现两列布局</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>页面布局进化史</title>
      <link href="/2020/06/20/CSS/%E5%B8%83%E5%B1%80%E8%BF%9B%E5%8C%96%E5%8F%B2/"/>
      <url>/2020/06/20/CSS/%E5%B8%83%E5%B1%80%E8%BF%9B%E5%8C%96%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="从事前端工作以来我是用过的页面布局方法"><a href="#从事前端工作以来我是用过的页面布局方法" class="headerlink" title="从事前端工作以来我是用过的页面布局方法"></a>从事前端工作以来我是用过的页面布局方法</h1><p>记得我刚从事互联网工作的时候先接触的就是<code>table</code>表格布局页面，当时css并没有那么的普及（也或是是我不太了解）哪个时候还是用的asp，access开发网站。当时做一个页面，要实现一个效果都是表格嵌套表格，一个背景图为了实现自适应需要把它分成三份分别放到不同的单元格当中，当时如果要做好一个比较复杂的页面需要写上好几百个表格单元格才能实现。</p><h2 id="布局第一阶段table表格"><a href="#布局第一阶段table表格" class="headerlink" title="布局第一阶段table表格"></a>布局第一阶段table表格</h2><pre><code class="html">&lt;table width=&quot;100%&quot; border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;  &lt;tr&gt;    &lt;td width=&quot;20%&quot;&gt;左&lt;/td&gt;    &lt;td width=&quot;auto&quot;&gt;右&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;</code></pre><p>上边代码是通过表格实现的左右两列布局结构，表格布局优点：宽度自适应，高度左右列能做到一样高；缺点：html代码多，写起来比较复杂，结构和表现都写在一起在页面结构复杂情况下不利于代码维护。</p><h2 id="css2中div-css实现布局"><a href="#css2中div-css实现布局" class="headerlink" title="css2中div+css实现布局"></a>css2中div+css实现布局</h2><p>css的出现使得页面结构和样式完全分离开，页面的内容由html结构来完成，内容的展示样式就交给了css来实现。同时样式可以单独写在一个文件里html中只需要通过link引入样式文件即可，使维护变得简单。</p><h3 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h3><blockquote><p>是通过给元素设置左右浮动实现</p></blockquote><pre><code class="html">&lt;div class=&quot;box&quot;&gt;  &lt;div class=&quot;left&quot;&gt;左&lt;/div&gt;  &lt;div class=&quot;right&quot;&gt;右&lt;/div&gt;&lt;/div&gt;&lt;style type=&quot;text/css&quot;&gt;  .left{float:left;width:20%;}  .right{float:right;width:80%;}  .box{overflow:hidden;}&lt;/style&gt;</code></pre><p>从上边代码可以看出，html代码比表格布局少了很多，但是灵活性更强了，所有的样式表现都有css来完成，我们可以在不改变html结构的情况下轻松让左右结构互换位置。只需要改变浮动方向即可。但是简单的同时又出现了新的问题，那就是元素浮动的时候已经脱离了文档流使得<code>box</code>元素不能按照内容高度自适应，高度变成了0像素。这个时候我们就需要给他设置其他代码来解决此问题。这就是所谓的浮动后父元素高度塌陷。</p><h3 id="定位布局"><a href="#定位布局" class="headerlink" title="定位布局"></a>定位布局</h3><blockquote><p>是通过给元素设置相对定位和绝对定位来实现</p></blockquote><pre><code class="html">&lt;div class=&quot;box&quot;&gt;  &lt;div class=&quot;left&quot;&gt;左&lt;/div&gt;  &lt;div class=&quot;right&quot;&gt;右&lt;/div&gt;&lt;/div&gt;&lt;style type=&quot;text/css&quot;&gt;  .box{position:relative;}  .left{position:absolute;left:0;top:0;width:20%;}  .right{position:absolute;left:20%;top:0;width: 80%;}&lt;/style&gt;</code></pre><p>定位布局也会造成父容器高度塌陷的情况，一般情况定位属性设置在一个元素上左边或者右边，然后让另一个默认撑开父元素</p><h3 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h3><blockquote><p>通过<code>inline-block</code>可以设置宽度高度的特性，并且可以设置按照父级百分百宽度实现布局</p></blockquote><pre><code class="html">&lt;div class=&quot;box&quot;&gt;  &lt;div class=&quot;left&quot;&gt;左&lt;/div&gt;  &lt;div class=&quot;right&quot;&gt;右&lt;/div&gt;&lt;/div&gt;&lt;style type=&quot;text/css&quot;&gt;  .box{position:relative;}  .left{position:absolute;left:0;top:0;width:20%;}  .right{position:absolute;left:20%;top:0;width: 80%;}&lt;/style&gt;</code></pre><h2 id="css3中的高级布局方法"><a href="#css3中的高级布局方法" class="headerlink" title="css3中的高级布局方法"></a>css3中的高级布局方法</h2><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><blockquote><p>flex布局又称为弹性盒模型布局，也就是说它可以自适应宽高，并且能够轻松的实现以前无法实现或者需要很复杂才能实现的效果。flex布局写法更加简单</p></blockquote><pre><code class="html">&lt;div class=&quot;box&quot;&gt;  &lt;div class=&quot;left&quot;&gt;左&lt;/div&gt;  &lt;div class=&quot;right&quot;&gt;右&lt;/div&gt;&lt;/div&gt;&lt;style type=&quot;text/css&quot;&gt;  .box{display:flex;}  .left{width: 300px; flex-shrink: 0;}  .right{flex-grow:1}&lt;/style&gt;</code></pre><p>上面的简单代码就实现了一个两列布局，左边宽度300像素，右边自适应宽度，并且两边的高度永远是等高的。我们看到使用flex方法能让我们在写代码上变得少了很多。</p><h3 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h3><blockquote><p>grid布局又称为网格布局，它是继flex布局后又一种很灵活的布局模式，flex布局只是一维的布局系统，而grid是一个二维的布局系统，它有行和列的概念，并且更灵活。</p></blockquote><pre><code class="html">&lt;div class=&quot;box&quot;&gt;  &lt;div class=&quot;left&quot;&gt;左&lt;/div&gt;  &lt;div class=&quot;right&quot;&gt;右&lt;/div&gt;&lt;/div&gt;&lt;style type=&quot;text/css&quot;&gt;  .box{display:grid; grid-template-columns: 300px 1fr;}&lt;/style&gt;</code></pre><p>从上面代码可以看到，grid布局在css代码上更加简单，只需要给父级设置属性就能轻松实现上面的两列布局</p><p>在现在的浏览器都能够很好的支持<code>flex</code>和<code>grid</code>布局，我们在开发中可以放心大胆的使用更加简单的布局方式</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JSON是一种轻量级数据交换格式</title>
      <link href="/2020/06/10/JavaScript/JSON/"/>
      <url>/2020/06/10/JavaScript/JSON/</url>
      
        <content type="html"><![CDATA[<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p><code>JSON</code>是一种数据格式，不是一种编程语言。虽然具有相同的语法形式，但 JSON 并不从属于 JavaScript。而且，并不是只有 JavaScript 才使用 <code>JSON</code>，毕竟JSON只是一种数据格式。很多编程语言都有针对 JSON 的解析器和序列化器。</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>JSON语法可以包含以下三种类型值：</p><ol><li>简单值：<code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>null</code>，也就是javascript中的基本数据类型，但是他不支持<code>undefined</code>;</li><li>对象：是一种复杂数据类型，表示的是一组无序的键值对儿。而每个键值对儿中的值可以是简单值，也可以是复杂数据类型的值</li><li>数组：也是一种复杂的数据类型，表示的是一组有序的的值的列表，可以通过数组的索引值(索引从0开始)来访问其中的值，数组中的值可以是：简单值、对象或数组</li></ol><h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><pre><code class="javascript">{    &quot;title&quot;: &quot;JavaScript&quot;,    &quot;authors&quot;: [&quot;name1&quot;, &quot;name2&quot;],    edition: 3,    year: 2011,    chapter:{        grammar:[&#39;运算符&#39;,&#39;表达式&#39;],        ajax: {            definition: &#39;ajax定义&#39;,            user: &#39;ajax使用&#39;        }    },    appendix: null}</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><blockquote><p>JSON 中对象的属性名任何时候都必须加双引号，在书写JSON的时候如果忘了给对象属性名加双引号或者把双引号写成单引号都是常见的错误。同时在同一级中属性名不能重复必须是唯一的，JSON中不能使用注释符来标注<br>javascript中的json没有这么严格要求，可以不用给属性名添加双号，或者可以是单引号，但是必输要按照javascript命名规范来属性，同时如果同级内出现同样的属性名，后出现的会替换到先出现的</p></blockquote><pre><code class="javascript">{    &quot;name&quot;: &#39;张三&#39;,    &#39;age&#39;: 30,  // 错误，键名不能用单引号    sex: &quot;男&quot; // 错误，键名必须使用双号括起来    age: 40, // 错误，出现了重复的键名    &quot;home&quot;: &quot;河北&quot;, // 错误，JSON最后一个值后面不能有逗号}</code></pre><p>上面的代码如果是在JSON文件中是会报错的，只有第一行的定义是正确的，其他三行都错误，如果是javascript定义的对象，上面的写法不会报错。</p><h2 id="javascript中json提供的方法"><a href="#javascript中json提供的方法" class="headerlink" title="javascript中json提供的方法"></a>javascript中json提供的方法</h2><p>在早期的javascript中解析JSON基本上只能用<code>eval()</code>函数来实现；而ECMAScript5对解析JSON的行为做了规范化，提供了全局的JSON对象可以通过JSON对象提供的方法轻松的解析和格式化JSON对象。</p><p>JSON对象包含两个方法: 用于解析 JavaScript Object Notation  (JSON) 的 parse() 方法，以及将对象/值转换为 JSON字符串的 stringify() 方法。除了这两个方法, JSON这个对象本身并没有其他作用，也不能被调用或者作为构造函数调用。</p><h3 id="stringify"><a href="#stringify" class="headerlink" title="stringify"></a>stringify</h3><blockquote><p>用于将JSON对象转换成JSON字符串，可以通过额外的参数, 控制仅包含某些属性, 或者以自定义方法来替换某些key对应的属性值。</p></blockquote><p><strong>语法：</strong></p><pre><code class="javascript">JSON.stringify(value[, replace | [] [, space]])</code></pre><p><strong>参数：</strong></p><ol><li><code>value</code>：将要序列化成字符串的对象或者数组的对象值。</li><li><code>replace</code>：可选参数，如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化；</li><li><code>space</code>：可选参数，指定缩进用的空白字符串，用于美化输出；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串（当字符串长度超过10个字母，取其前10个字母），该字符串将被作为空格；如果该参数没有提供（或者为 null），将没有空格。</li></ol><pre><code class="javascript">var firstJson = {  &quot;a&quot;: 10,  &quot;b&quot;: 20,  &quot;c&quot;: 30,  &quot;20&quot;: &#39;aaa&#39;}/* 把json转换成字符串 */JSON.stringify(firstJson);// {&quot;20&quot;:&quot;aaa&quot;,&quot;a&quot;:10,&quot;b&quot;:20,&quot;c&quot;:30}/* 第二个参数是数组，根据数组提供的值和对象的键值做==对比返回存在此键值的值 */JSON.stringify(firstJson, [&#39;a&#39;, 20, &#39;x&#39;]);// {&quot;a&quot;:10,&quot;20&quot;:&quot;aaa&quot;}  这个对比会进行类型转换/* 第二个值时方法的时候 */JSON.stringify(firstJson, function(key, value){  // 先判断key是否为真因为第一次循环会把整个对象作为参数传入，键值为空，第二次开始遍历每个值  if(key){    // 为每个值加10    value += 10;  }  return value;});// {&quot;20&quot;:&quot;aaa10&quot;,&quot;a&quot;:20,&quot;b&quot;:30,&quot;c&quot;:40}/* 第三个参数 */JSON.stringify(firstJson, null, 2);/* {  &quot;20&quot;: &quot;aaa&quot;,  &quot;a&quot;: 10,  &quot;b&quot;: 20,  &quot;c&quot;: 30}*/</code></pre><h3 id="toJSON"><a href="#toJSON" class="headerlink" title="toJSON"></a>toJSON</h3><blockquote><p><em>此方法并非是JSON中的方法</em>，如果一个被序列化的对象拥有 toJSON 方法，那么该 toJSON 方法就会覆盖该对象默认的序列化行为：不是该对象被序列化，而是调用 toJSON 方法后的返回值会被序列化</p></blockquote><pre><code class="javascript">/* 对象形式 */var firstJson = {  &quot;a&quot;: 10,  &quot;b&quot;: 20,  &quot;c&quot;: 30,  &quot;20&quot;: &#39;aaa&#39;,  toJSON: function(){    return {&#39;x&#39;:1, &#39;y&#39;:10};  }}JSON.stringify(firstJson);// {&quot;x&quot;:1,&quot;y&quot;:10}/* 数组形式 */var arr = [1, 2, 4, &#39;abc&#39;, true, 4.5, {a:10, b:20}];// 可以在数组原型上添加toJSON方法。Array.prototype.toJSON = function(){    return &#39;arr&#39;;}// 可以在实例化对象中添加toJSON方法效果一样/* arr.toJSON = function(){    return &#39;arr&#39;;} */var getArrStr1 = JSON.stringify(arr);// &quot;arr&quot;</code></pre><h3 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h3><blockquote><p>用来解析由字符串描述的JavaScript值或对象。</p></blockquote><p><strong>基本语法：</strong></p><pre><code class="javascript">JSON.parse(text[, reviver])</code></pre><p><strong>参数说明：</strong></p><ol><li><code>text</code>：必选，要被解析成 JavaScript 值的字符串，若传入的字符串不符合 JSON 规范，则会抛出 SyntaxError 异常。</li><li><code>reviver</code>：可选，转换器，如果传入该参数(函数)，可以用来修改解析生成的原始值，调用时机在 parse 函数返回之前。</li></ol><p><strong>示例：</strong></p><pre><code class="javascript">/* 只传入一个要转换的值 */// 可以使空对象字符串JSON.parse(&#39;{}&#39;);              // {}// 对象字符串JSON.parse(&#39;{a:10, b:20}&#39;);   // SyntaxError 这里的键值必须使用单引号或者双引号括起来// 对象字符串JSON.parse(&#39;{&quot;a&quot;:10, &quot;b&quot;:20}&#39;);   // {a: 10, b:20}// 可以是字符串正假值JSON.parse(&#39;true&#39;);            // true// 不可以直接使用字符串JSON.parse(&#39;foo&#39;);             // SyntaxError错误// 字符串需要引号括起来JSON.parse(&#39;&quot;foo&quot;&#39;);           // &quot;foo&quot;// 可以是数组JSON.parse(&#39;[1, 5, &quot;false&quot;, true]&#39;); // [1, 5, &quot;false&quot;, true]// 可以是null值JSON.parse(&#39;null&#39;);            // null// 不能使用undefinedJSON.parse(undefined)         // SyntaxError错误// 不能使用functionJSON.parse(function(){})         // SyntaxError错误/* 传入递归函数 */var getJSON = JSON.parse(&#39;{&quot;a&quot;: 1, &quot;b&quot;: &quot;2&quot;,&quot;c&quot;: {&quot;d&quot;: 4, &quot;e&quot;: {&quot;f&quot;: 6}},&quot;g&quot;:null, &quot;f&quot;:&quot;hello&quot;}&#39;, function (k, v) {  console.log(k);  // 这里依次输出的顺序是：a, b, d, f, e, c, g, f &#39;&#39;  if(typeof v == &#39;number&#39;){  //这里通过遍历判断值是否为数字类型是进行处理并返回    return v + 10;  }  if(k == &quot;f&quot;){ // 这里判断键值是否是f，如果是返回undefined，也就是删除此值    return undefined;  }  // 默认返回  return v;});console.log(getJSON);  // { a: 11, b: &#39;2&#39;, c: { d: 14, e: { f: 16 } }, g: null }</code></pre><ol><li><p>通过上边实例可以看出，我们在使用<code>parse</code>方法的时候必须传入正确的JSON支持的数据类型：JSON对象、数组、数值、字符串、布尔值和 空(null) 。</p></li><li><p>当我们提供第二个值的时候，他会为每一个值执行一次这个方法，并且把键当做第一个参数，值当做第二个参数传入该函数，并且在函数内部进行一些处理，当我们想要排除一些指定的键值对的话我们可以返回undefined，就会删除该项。并且它的执行顺序是依次顺序执行，当遇到的是对象形式，先便利里边的值，然后再输出该对象的键值，也就是由内到外执行，最后便利整个对象并且把转换后的整体返回，这个和 <code>stringify</code> 中的<code>replace</code>方法刚好相反。<br>这里还需要主要的是在遍历的时候<code>reviver</code>函数内的this指向的是当前的对象，如果遇到的键值是一个对象，那么进入该对象遍历时，this会执行该键值的对象。</p></li></ol><h2 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h2><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" rel="external nofollow noopener noreferrer" target="_blank">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>css3中的@font-face你真的了解吗</title>
      <link href="/2020/05/26/CSS3/font-face/"/>
      <url>/2020/05/26/CSS3/font-face/</url>
      
        <content type="html"><![CDATA[<h1 id="css3中的自定义字体方法-font-face"><a href="#css3中的自定义字体方法-font-face" class="headerlink" title="css3中的自定义字体方法@font-face"></a>css3中的自定义字体方法@font-face</h1><blockquote><p><code>@font-face</code>属性可以让我们自定义网站字体属性，然后引用到想要应用该字体的元素上。</p></blockquote><h2 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h2><pre><code class="css">@font-face {  font-family: &lt;font-name&gt;;  src: local( &lt;family-name&gt; ) | &lt;url&gt; [format(&quot;formatName&quot;)][,&lt;url&gt; [format(&quot;formatName&quot;)]]*;  unicode-range: &lt;unicode-range&gt;;  font-variant: &lt;font-variant&gt;;  font-feature-settings: &lt;font-feature-settings&gt;;  font-variation-settings: &lt;font-variation-settings&gt;;  font-stretch: &lt;font-stretch&gt;;  font-weight: &lt;font-weight&gt;;  font-style: &lt;font-style&gt;;  font-display: &lt;font-display&gt;;}</code></pre><h2 id="属性规则说明"><a href="#属性规则说明" class="headerlink" title="属性规则说明"></a>属性规则说明</h2><h3 id="font-family"><a href="#font-family" class="headerlink" title="font-family"></a>font-family</h3><blockquote><p>给你引入的字体起一个专属的字体名字，<code>font-name</code>，然后他会在元素<code>font-family:</code>中使用，如<code>div{font-family:font-name}</code>；</p></blockquote><h3 id="src"><a href="#src" class="headerlink" title="src"></a>src</h3><blockquote><p>用于指定加载字体文件的路径或者加载本地字体</p></blockquote><h4 id="local"><a href="#local" class="headerlink" title="local"></a>local</h4><blockquote><p>加载一个本地字体，<code>font-name</code>表示本地的字体名称，比如<code>Microsoft YaHei | 微软雅黑</code>；如果本地有应用此字体显示文本。</p></blockquote><p><strong>示例：</strong></p><pre><code class="css">/* 加载一个本地字体 */@font-face{  font-family: myFont;  src: local(&#39;Microsoft YaHei&#39;);}/* 加载多个本地字体 */@font-face{  font-family: myFont;  src:  local(黑体), local(&quot;Microsoft YaHei&quot;), local(&quot;HelveticaNeue-Light&quot;), local(&quot;Helvetica Neue Light&quot;),  local(&quot;PingFang SC&quot;), local(sans-serif);}/* 应用自定义字体 */.box{  font-family: myFont;}</code></pre><p>在上边代码中看到，可以使用一个或多个<code>local</code>，多个之间用逗号分开，括号中的字体名称可以使用单引号或者双引号括起来，也可以不带引号直接写字体名称，有空格的必须添加引号，<em>但是只能写一个字体名称</em>；<br>上边的写法让我们在定义字体的时候变得方便很多，我们只需要定义好自定义名称然后直接引用该字体等同于下边代码：</p><pre><code class="css">.box{  font-family: 黑体, &quot;Microsoft YaHei&quot;, &quot;HelveticaNeue-Light&quot;, &quot;Helvetica Neue Light&quot;, &quot;PingFang SC&quot;, sans-serif;}</code></pre><h4 id="url"><a href="#url" class="headerlink" title="url"></a>url</h4><blockquote><p>表示服务器端提供的字体地址，这个也是可以使用多个，多个之间用逗号隔开，一般写多个是为了浏览器兼容加载不同格式的字体。目前web可以加载六种格式的字体：</p></blockquote><ol><li><p><code>EOT</code>：全拼：<code>Embedded_OpenType</code>，是由微软开发的字体格式规范，所以只适用于IE浏览器。<a href="https://en.wikipedia.org/wiki/Embedded_OpenType" rel="external nofollow noopener noreferrer" target="_blank">详细介绍</a></p><p>兼容：<br><img src="/2020/05/26/CSS3/font-face/EOT_caniuse.png" alt="image"><br><a href="https://caniuse.com/#search=EOT" rel="external nofollow noopener noreferrer" target="_blank">兼容详情</a></p></li><li><p><code>TTF</code>：全拼：<code>TrueType</code>，是一种轮廓字体标准，最早是由苹果公司研发，后来成为<code>Mac OS</code>、<code>Microsoft Windows</code>系统中最常用的字体格式。<a href="https://en.wikipedia.org/wiki/TrueType" rel="external nofollow noopener noreferrer" target="_blank">详细介绍</a></p><p>兼容：<br><img src="/2020/05/26/CSS3/font-face/TTF_OTF_caniuse.png" alt="image"><br><a href="https://caniuse.com/#search=TTF" rel="external nofollow noopener noreferrer" target="_blank">兼容详情</a></p></li><li><p><code>OTF</code>：全拼：<code>OpenType</code>，是可缩放计算机字体的格式，是由微软和Adobe公司联合开发。<a href="https://en.wikipedia.org/wiki/OpenType" rel="external nofollow noopener noreferrer" target="_blank">详细介绍</a></p><p>兼容：<br><img src="/2020/05/26/CSS3/font-face/TTF_OTF_caniuse.png" alt="image"><br><a href="https://caniuse.com/#search=OTF" rel="external nofollow noopener noreferrer" target="_blank">兼容详情</a></p></li><li><p><code>WOFF</code>：全拼：<code>Web Open Font Format</code>web网络开放字体格式，他是专为网络设计的一种字体格式，<code>WOFF</code>是把<code>OpenType</code>和<code>TrueType</code>字体进行了封装，并进行了压缩优化，它使用了广泛应用的<code>zlib</code>压缩，并添加了XML元数据，这种字体格式体积更小，适用于网络传输，可以使用户体验做到更好。<a href="https://en.wikipedia.org/wiki/Web_Open_Font_Format" rel="external nofollow noopener noreferrer" target="_blank">详细介绍</a></p><p>兼容：<br><img src="/2020/05/26/CSS3/font-face/WOFF_caniuse.png" alt="image"><br><a href="https://caniuse.com/#feat=mdn-css_at-rules_font-face_woff" rel="external nofollow noopener noreferrer" target="_blank">兼容详情</a></p></li><li><p><code>WOFF2</code>：它是WOFF的升级版，它使用<code>Brotli</code>进行字节级压缩，比<code>WOFF</code>体积更小</p><p>兼容：<br><img src="/2020/05/26/CSS3/font-face/WOFF2_caniuse.png" alt="image"><br><a href="https://caniuse.com/#feat=mdn-css_at-rules_font-face_woff_2" rel="external nofollow noopener noreferrer" target="_blank">兼容详情</a></p></li><li><p><code>SVG</code>：全拼：<code>Scalable Vector Graphics</code>可缩放矢量图形，是一种基于可扩展标记语言（XML）的矢量图像格式，用于二维图形，并支持交互性和动画，字体中就是使用svg技术来呈现文字样式。我测试只有苹果<code>Safari</code>支持； <a href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics" rel="external nofollow noopener noreferrer" target="_blank">详细介绍</a></p><p>兼容：<br><img src="/2020/05/26/CSS3/font-face/SVG_caniuse.png" alt="image"><br><a href="https://caniuse.com/#feat=svg-fonts" rel="external nofollow noopener noreferrer" target="_blank">兼容详情</a></p></li></ol><h4 id="format"><a href="#format" class="headerlink" title="format"></a>format</h4><blockquote><p>可选值，表示给加载的外部字体指定字体格式，用来告诉浏览器让浏览器能够识别所使用的字体格式，可用的类型有 <code>embedded-opentype</code>, <code>truetype</code>, <code>opentype</code>, <code>woff</code>, <code>woff2</code>, <code>svg</code>。分别对应上边我们介绍的字体格式。</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">/* 加载一种字体格式 */@font-face{  font-family: &quot;myFontName&quot;;  src:  url(&#39;font.woff&#39;) format(&#39;woff&#39;);}/* 加载多个字体格式，兼容更多浏览器 */@font-face{  font-family: &quot;myFontName&quot;;  src: url(&#39;font.eot&#39;); /* IE9*/  src: url(&#39;font.eot?#iefix&#39;) format(&#39;embedded-opentype&#39;), /* IE6-IE8 */  url(&#39;font.woff2&#39;) format(&#39;woff2&#39;),  url(&#39;font.woff&#39;) format(&#39;woff&#39;), /* chrome、firefox */  url(&#39;font.ttf&#39;) format(&#39;truetype&#39;), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/  url(&#39;font.svg#Alibaba-PuHuiTi-Regular&#39;) format(&#39;svg&#39;); /* iOS 4.1- */}</code></pre><p>从上边语法来看我们可以加载一个格式的字体文件，也可以加载多个格式字体，之间用逗号分开，浏览器会优先读取写在前面的字体格式并且检测是否支持，如果支持就使用该格式的字体文件。</p><h3 id="font-weight"><a href="#font-weight" class="headerlink" title="font-weight"></a>font-weight</h3><blockquote><p>表示自定义字体规则的字重程度，我们可以给一个字体指定不同的粗细规则引用不同规格的字体文件。</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">/* Single values */font-weight: normal;font-weight: bold;font-weight: 400;/* Multiple Values */font-weight: normal bold;font-weight: 300 500;</code></pre><p><strong>取值说明：</strong></p><ol><li><code>normal</code>：默认值，表示该字体规则是在默认情况下的字体，也就是在应用改字体的元素中不规定字体的粗细情况或者<code>font-weight: 400 | normal</code>下应用该字体；</li><li><code>bold</code>：粗体，表示元素设置<code>font-weight: bold | 700</code>，或者使用<code>&lt;b&gt;</code>、<code>&lt;strong&gt;</code>元素的时候应用该字体。</li><li><code>400</code>：也可以设置成数值，在CSS Fonts Level 4之前的版本只能去<code>100-900</code>的100倍数值，之后的数值可以去<code>1-1000</code>的任意数值。</li><li><code>normal bold</code>：可以使用多个关键字来定义此字体规则，多个关键字之间用逗号分开，表示元素字重设置为此关键字中的其中一个值时应用该字体。</li><li><code>300 500</code>：也可以使用多个数值来定义此字体规则。</li></ol><p><strong>取数值情况下应该对应的每个字体：</strong></p><table><thead><tr><th>value</th><th>对应的字体的自重名称</th></tr></thead><tbody><tr><td>100</td><td>Thin (Hairline)</td></tr><tr><td>200</td><td>Extra Light (Ultra Light)</td></tr><tr><td>300</td><td>Light</td></tr><tr><td>400</td><td>Normal</td></tr><tr><td>500</td><td>Medium</td></tr><tr><td>600</td><td>Semi Bold (Demi Bold)</td></tr><tr><td>700</td><td>Bold</td></tr><tr><td>800</td><td>Extra Bold (Ultra Bold)</td></tr><tr><td>900</td><td>Black (Heavy)</td></tr></tbody></table><p><strong>代码示例：</strong>因为字体有版权限制，这里我们使用阿里的免费商用字体来演示</p><p><a href="https://codepen.io/qwguo88/full/jObgQYG" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/jObgQYG</a></p><iframe height="400" style="width: 100%;" scrolling="no" title="font-face-font-weight" src="https://codepen.io/qwguo88/embed/jObgQYG?height=400&theme-id=30742&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/jObgQYG" rel="external nofollow noopener noreferrer" target="_blank">font-face-font-weight</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p>从上边的案例我们可以看出，先自定义了一个名为<code>FW</code>的字体，并且使用<code>font-weight</code>定义不同字重使用不同的字体。在上边的案例中定义了5中字重样式，分别是<code>bold</code>：<em>阿里巴巴-普惠体-Heavy</em>，<code>100</code>：<em>杨任东竹石体-Bold</em>，<code>200</code>：<em>站酷高端黑</em>，<code>300 600</code>：<em>庞门正道标题体2</em>，<code>900</code>：<em>思源黑体-粗</em><br>然后给div设置<code>font-family:FW</code>;最后我们分别给这个div下的每个段落设置不同的<code>font-weight</code>,段落的字体就会根据不同的字重来应用不同的字体。<br>我们可以把自定义字体看成我们平常使用系统内置字体一样，当我们设置字体为<code>微软雅黑</code>，并且设置不同的字重他会在系统中寻找每个自重对应的字体，然后来显示。</p><h3 id="font-style"><a href="#font-style" class="headerlink" title="font-style"></a>font-style</h3><blockquote><p>表示自定义字体规则的样式表现形式，我们可以给一个字体指定不同的样式规则引用不同规格的字体文件。</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">font-style: normal | italic | oblique &lt;angle&gt;{0,2}</code></pre><p><strong>取值说明：</strong></p><ol><li><code>normal</code>：默认字样式使用的字体规则，当我们不设置或者设置成此值时的字体。</li><li><code>italic</code>：表示字样式设置成斜体的时候使用的字体规则。</li><li><code>oblique</code>：表示字样式设置成斜体的时候使用的字体规则。</li></ol><p>当我们同时定义<code>italic</code>和<code>oblique</code>规则的字体时，写在后边的生效所设置的斜体字体显示。</p><p><strong>代码示例：</strong> <a href="https://codepen.io/qwguo88/full/RwWXONo" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/RwWXONo</a></p><iframe height="300" style="width: 100%;" scrolling="no" title="font-face-font-style" src="https://codepen.io/qwguo88/embed/RwWXONo?height=300&theme-id=30742&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/RwWXONo" rel="external nofollow noopener noreferrer" target="_blank">font-face-font-style</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h3 id="unicode-range"><a href="#unicode-range" class="headerlink" title="unicode-range"></a>unicode-range</h3><blockquote><p>表示自定义字体规则的unicode字符范围</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">/* unicode-range 取值规则 */unicode-range: U+26;                /* 单个值 */unicode-range: U+0-7F;              /* 字符编码区间*/unicode-range: U+0025-00FF;        /* 字符编码区间 */unicode-range: U+4??;              /* 通配符区间 */unicode-range: U+0025-00FF, U+4??; /* 可以写多个值，多个值之间用逗号分开 */</code></pre><p><strong>取值说明：</strong><br>取值规则：前边是<code>U+</code>后边跟上字符的<code>charCode</code>值</p><ol><li>可以是单个值，表示文本中只有该字符的字应用该字体。</li><li>可以使用一个字符区间，表示文本中如果有在此区间的文字将应用改字体规则。</li><li>也可以使用通配符来设置一个区间规则其中<code>?</code>表示一个16进制<code>0-F</code>的之间的值<code>U+4??</code>表示 <code>U+400</code> 到 <code>U+4FF</code>区间的字符编码。</li><li>也可以使用多个值，多个值之间使用逗号分开。</li></ol><p><strong>案例：</strong><a href="https://codepen.io/qwguo88/full/XWXWqmP" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/XWXWqmP</a></p><iframe height="300" style="width: 100%;" scrolling="no" title="font-face-unicode-range" src="https://codepen.io/qwguo88/embed/XWXWqmP?height=300&theme-id=30742&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/XWXWqmP" rel="external nofollow noopener noreferrer" target="_blank">font-face-unicode-range</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p>从上边案例可以看出，<code>unicode-range</code>是用来规定应用当前字体规则的文字<code>unicode</code>码在规则内的将以此字体规则显示字体。<br>他能让我们来控制一个段落中的个别字的显示效果，一般要显示的字体规则排在最前面，将优先显示。</p><!-- ### font-variant### font-feature-settings### font-variation-settings### font-stretch --><h3 id="font-display"><a href="#font-display" class="headerlink" title="font-display"></a>font-display</h3><blockquote><p>设置自定义字体在没有加载完的显示方式取值如下：</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">font-display: auto | block | swap | fallback | optional</code></pre><ol><li><code>auto</code>：字体显示策略由用户代理定义。</li><li><code>block</code>：为字体提供一个短暂的阻塞周期和无限的交换周期。也就是说等字体加载完以后字体显示效果会自动更新成改字体</li><li><code>swap</code>：为字体提供一个非常小的阻塞周期和无限的交换周期。也就是说等字体加载完以后字体显示效果会自动更新成改字体</li><li><code>fallback</code>：为字体提供一个非常小的阻塞周期和短暂的交换周期。也就是说等字体加载在过了一定的交互周期后加载完字体将不进行更新显示</li><li><code>optional</code>：为字体提供一个非常小的阻塞周期，并且没有交换周期。也就是说等字体加载不进行更新显示</li></ol><h2 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h2><ol><li><a href="https://webplatform.github.io/docs/tutorials/typography/font-face/" rel="external nofollow noopener noreferrer" target="_blank">https://webplatform.github.io/docs/tutorials/typography/font-face/</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face/font-display" rel="external nofollow noopener noreferrer" target="_blank">https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face/font-display</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2016/11/css-unicode-range-character-font-face/" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhangxinxu.com/wordpress/2016/11/css-unicode-range-character-font-face/</a></li><li><a href="https://www.w3cplus.com/css/font-display-masses.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.w3cplus.com/css/font-display-masses.html</a></li></ol><h2 id="字体下载格式转换网站"><a href="#字体下载格式转换网站" class="headerlink" title="字体下载格式转换网站"></a>字体下载格式转换网站</h2><ol><li><a href="https://www.fontke.com/tool/fontface/" rel="external nofollow noopener noreferrer" target="_blank">https://www.fontke.com/tool/fontface/</a></li><li><a href="http://www.fonts.net.cn/" rel="external nofollow noopener noreferrer" target="_blank">http://www.fonts.net.cn/</a></li><li><a href="https://fonts.google.com/" rel="external nofollow noopener noreferrer" target="_blank">https://fonts.google.com/</a></li></ol><h2 id="字体压缩工具"><a href="#字体压缩工具" class="headerlink" title="字体压缩工具"></a>字体压缩工具</h2><ol><li><a href="http://www.fonts.net.cn/" rel="external nofollow noopener noreferrer" target="_blank">http://www.fonts.net.cn/</a> <strong>字体天下</strong></li><li><a href="http://www.ziticq.com/" rel="external nofollow noopener noreferrer" target="_blank">http://www.ziticq.com/</a> <strong>字体传奇</strong></li><li><a href="https://www.hellofont.cn/" rel="external nofollow noopener noreferrer" target="_blank">https://www.hellofont.cn/</a> <strong>字由</strong></li><li><a href="http://fontstore.baidu.com/static/editor/index.html" rel="external nofollow noopener noreferrer" target="_blank">http://fontstore.baidu.com/static/editor/index.html</a>   <strong>百度在线字体编辑器</strong></li><li><a href="https://efe.baidu.com/" rel="external nofollow noopener noreferrer" target="_blank">https://efe.baidu.com/</a>   <strong>百度字体处理</strong></li><li><a href="https://www.fontsquirrel.com/tools/webfont-generator" rel="external nofollow noopener noreferrer" target="_blank">https://www.fontsquirrel.com/tools/webfont-generator</a> <strong>字体格式换</strong></li><li><a href="https://www.fontke.com/tool/fontface/" rel="external nofollow noopener noreferrer" target="_blank">https://www.fontke.com/tool/fontface/</a> <strong>字体转换</strong></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
            <tag> FontFace </tag>
            
            <tag> font-face </tag>
            
            <tag> font-family </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FontFace对象</title>
      <link href="/2020/05/25/JavaScript/FontFace/"/>
      <url>/2020/05/25/JavaScript/FontFace/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript中FontFace对象的使用"><a href="#JavaScript中FontFace对象的使用" class="headerlink" title="JavaScript中FontFace对象的使用"></a>JavaScript中FontFace对象的使用</h1><blockquote><p><code>FontFace</code>字面理解就是字体脸，也就是文字字体样式的意思，它是通过使用javascript来定义字体对象，并且引入客户端没有安装得字体文件，可以是者服务器端，或者是第三方字体库文件</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>基本语法：</strong></p><pre><code class="javascript">concat fontFace  = new FontFace(&#39;fontFamily&#39;, &#39;url(fontUrl) | ArrayBuffer&#39;, descriptors);</code></pre><p><strong>参数说名：</strong></p><ol><li><code>fontFamily</code>：字符串，自定义的要应用到页面或者元素中得字体名称；</li><li><code>fontUrl</code>：字符串，字体文件的路径，可以是第三方字体文件路径,但是需要请求的地址服务器开启跨越访问，此值必须要用<code>url()</code>包裹起来；</li><li><code>ArrayBuffer</code>：用于描述的外部资源构建的二进制编码数组</li><li><code>descriptions</code>：对象形式，可选值，用来设置字体归属于那种属性下的字体规则，如字体样式，字体加粗，字体字符串范围等，还有该规则的显示行为等；可以设置得值：<ul><li><code>family</code>: 定义字体名称，这里的设置会被第一个参数值替代，但是我们可以通过实例对象的<code>fontFace.family</code>属性进行更改。</li><li><code>style</code>: 设置当前字体规则的<code>font-style</code>值，也就是当应用改规则的元素设置了相对于的值将加载改字体规则，取值为对应css中的<code>font-style</code>取值；</li><li><code>weight</code>: 设置字体的粗细值，对应css中的<code>font-weight</code>取值；</li><li><code>stretch</code>: 设置如何拉伸字体，对应css中的<code>font-stretch</code>取值；</li><li><code>unicodeRange</code>: 定义字体支持的UNICODE字符范围</li><li><code>variant</code>: variant</li><li><code>featureSettings</code>: Feature settings</li><li><code>display</code>：设置字体在没有加载完的显示规则取值如下：<ul><li><code>auto</code> 字体显示策略由用户代理定义。</li><li><code>block</code> 为字体提供一个短暂的阻塞周期和无限的交换周期。也就是说等字体加载完以后字体显示效果会自动更新成改字体</li><li><code>swap</code> 为字体提供一个非常小的阻塞周期和无限的交换周期。也就是说等字体加载完以后字体显示效果会自动更新成改字体</li><li><code>fallback</code> 为字体提供一个非常小的阻塞周期和短暂的交换周期。也就是说等字体加载在过了一定的交互周期后加载完字体将不进行更新显示</li><li><code>optional</code> 为字体提供一个非常小的阻塞周期，并且没有交换周期。也就是说等字体加载不进行更新显示</li></ul></li></ul></li></ol><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><img src="/2020/05/25/JavaScript/FontFace/FontFace_caniuse.png" alt="image"></p><p>从图上可以看出这是一个新的对象方法，<code>IE</code>，<code>Edge18-</code>，等低版本浏览器基本不兼容这个对象，如果我们要做兼容可以使用下边介绍的异步加载方式；</p><h2 id="创建FontFace对象"><a href="#创建FontFace对象" class="headerlink" title="创建FontFace对象"></a>创建FontFace对象</h2><blockquote><p>创建<code>FontFace</code>对象和创建普通对象基本相同，用new 关键字创建</p></blockquote><p><strong>实例：</strong></p><pre><code class="javascript">var myFonts = new FontFace(&#39;myFontName&#39;, &#39;url(ShouShu.ttf)&#39;, {    style: &#39;italic&#39;,  //表示该字体规则为斜体规则，只有在应用此规则字体的元素中设置了`font-style:italic`时应用该规则    weight: 700,  //表示改字体规则为粗体规则，只有在应用此规则字体的元素中设置了`font-weight:700|bold`时应用改规则    display: &#39;swap&#39;,    family: &#39;ali&#39;,  //这个值被第一个参数代替});</code></pre><h3 id="FontFace对象属性"><a href="#FontFace对象属性" class="headerlink" title="FontFace对象属性"></a>FontFace对象属性</h3><p><img src="/2020/05/25/JavaScript/FontFace/fontFace_object_property.png" alt="image"></p><p>从图上可以看出，FontFace对象的属性跟<code>descriptions</code>参数基本相同。我们可以通过对象属性来更改这些值。比如可以通过<code>fontFace.family=&quot;newName&quot;</code>来更改之前我们new实例化时定义得第一个参数的值。</p><h3 id="FontFace对象方法"><a href="#FontFace对象方法" class="headerlink" title="FontFace对象方法"></a>FontFace对象方法</h3><ol><li><code>load()</code>：<code>FontFace</code>对象为我们提供了一个方法，表示当字体文件加载完毕以后的方法，它返回一个<code>Promise</code>对象，并且使用当前的<code>FontFace</code>对象进行解析</li></ol><h2 id="将创建的FontFace字体添加到页面中"><a href="#将创建的FontFace字体添加到页面中" class="headerlink" title="将创建的FontFace字体添加到页面中"></a>将创建的FontFace字体添加到页面中</h2><blockquote><p>我们创建完对象以后并不能直接在页面中生效，需要我们通过<code>FontFaceSet</code>对象方法将字体添加到页面中，才能使页面中的字体生效，我们可以通过使用<code>document.fonts</code>隐式引用<code>FontFaceSet</code>对象，并且使用它的<code>add()</code>方法将字体添加到页面。</p></blockquote><h3 id="通过字体Promise回调添加"><a href="#通过字体Promise回调添加" class="headerlink" title="通过字体Promise回调添加"></a>通过字体Promise回调添加</h3><p><strong>语法：</strong></p><pre><code class="javascript">var myFonts = new FontFace(&#39;myFontName&#39;, &#39;url(ShouShu.ttf)&#39;,{});myFonts.load().then(function(loadFace){  document.fonts.add(loadFace);});</code></pre><p>上面代码我们使用了<code>load()</code>方法，当字体文件加载完毕以后再执行添加操作。</p><h3 id="通过Ajax获取字体文件后回调添加"><a href="#通过Ajax获取字体文件后回调添加" class="headerlink" title="通过Ajax获取字体文件后回调添加"></a>通过Ajax获取字体文件后回调添加</h3><p><em><strong>这里我们也可以使用异步的方式加载字体文件</strong></em></p><p><strong>语法：</strong></p><pre><code class="javascript">var xhr = new XMLHttpRequest(); // 定义一个异步对象xhr.open(&#39;GET&#39;, &#39;ShouShu.ttf&#39;, true); // 异步GET方式加载字体xhr.responseType = &quot;arraybuffer&quot;; //把异步获取类型改为arraybuffer二进制类型xhr.onload = function(){  // 这里做了一个判断：如果浏览器支持FontFace方法执行  if(typeof FontFace != &#39;undefined&#39;){    var buffer = this.response;  //获取字体文件二进制码    var myFonts = new FontFace(&#39;myFontName&#39;, buffer);  // 通过二进制码实例化字体对象    document.fonts.add(myFonts); // 将字体对象添加到页面中  }else{    // 如果浏览器不支持FontFace方法，直接添加样式到页面    var styles = document.createElement(&#39;style&#39;);    styles.innerHTML = &#39;@font-face{font-family:&quot;myFontName&quot;;src:url(&quot;ShouShu.ttf&quot;) format(&quot;truetype&quot;);font-display:swap;}&#39;;    console.log(document.getElementsByTagName(&#39;head&#39;));    document.getElementsByTagName(&#39;head&#39;)[0].appendChild(styles);  }}xhr.send();</code></pre><h2 id="页面中使用我们添加的字体"><a href="#页面中使用我们添加的字体" class="headerlink" title="页面中使用我们添加的字体"></a>页面中使用我们添加的字体</h2><blockquote><p>我们使用字体文件有两种方式，一种是事先在css中定义，另一种是通过js改变</p></blockquote><h3 id="css事先定义好"><a href="#css事先定义好" class="headerlink" title="css事先定义好"></a>css事先定义好</h3><pre><code class="html">&lt;!-- css --&gt;&lt;style&gt;  .box{    font-family: myFont; /*这里我们先定义好使用的字体*/  }&lt;/style&gt;&lt;!-- html --&gt;&lt;div class=&quot;box&quot;&gt;执子之手，方知子丑，泪流满面，子不走我走&lt;/div&gt;&lt;!-- js --&gt;&lt;script&gt;  // 页面加载完以后加载字体文件  window.onload = function(){    var myFonts = new FontFace(&#39;myFont&#39;, &#39;url(ShouShu.ttf)&#39;,{display: &#39;swap&#39;});    myFonts.load().then(function(loadFace){      document.fonts.add(loadFace);    });  }&lt;/script&gt;</code></pre><h3 id="通过js更改元素的字体"><a href="#通过js更改元素的字体" class="headerlink" title="通过js更改元素的字体"></a>通过js更改元素的字体</h3><pre><code class="javascript">// 页面加载完以后加载字体文件window.onload = function(){  var myFonts = new FontFace(&#39;myFont&#39;, &#39;url(ShouShu.ttf)&#39;,{display: &#39;swap&#39;});  myFonts.load().then(function(loadFace){    document.fonts.add(loadFace);    // 给body设置字体样式 Arial为后补字体    document.body.style.fontFamily = &#39;myFont, Arial&#39;;    //或者单独给元素设置    var box = document.getElementsByClassName(&quot;box&quot;);    for (var i = 0; i &lt; box.length; i++) {      box[i].style.fontFamily = &quot;myFont, Arial&quot;;    }  });}</code></pre><h2 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h2><ol><li><a href="https://webplatform.github.io/docs/tutorials/typography/fontface/" rel="external nofollow noopener noreferrer" target="_blank">https://webplatform.github.io/docs/tutorials/typography/fontface/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> FontFace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css3中的变量</title>
      <link href="/2020/05/21/CSS3/variables/"/>
      <url>/2020/05/21/CSS3/variables/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS3新功能之变量：variables"><a href="#CSS3新功能之变量：variables" class="headerlink" title="CSS3新功能之变量：variables"></a>CSS3新功能之变量：variables</h1><blockquote><p>css3为我们提供了一个强大的功能自定义属性，也就是变量，他能让我们更改色系、皮肤、自适配变得简单。我们只需要更改一些我们事先定义好的变量就可以轻松实现各种效果。特别是我们在开发大型项目的时候有多处使用相同的值来表示，这个时候我们就可以吧相同的属性值抽离出来定义成变量方便我们后期统一修改</p></blockquote><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><pre><code class="css">/* 定义全局变量 */:root{  --navColor: #c00;  --navPadding: 10px;}/* 定义局部变量 */selector{  --nameFont: italic small-caps 400 12px / 20px &#39;微软雅黑&#39;;  --boxBorder: 2px solid rgba(0, 0, 0, .2);}/* 使用var函数定义变量 */selector{  --borderWidth: 8px;  --borderColor: red;  --borderStyle: solid;  --border: var(--borderWidth) var(--borderColor) var(--borderStyle);  border: var(--border);}</code></pre><p>从上面可以看出在css中定义变量和声明一条css规则差不多只是前边使用<code>--</code>两个中横线后边跟着变量名。上面的代码<code>:root</code>中定义的变量为全局变量可以在任何元素中使用；<code>selector</code>中定义的变量为局部变量，只能在选择器范围内，和他的子元素中使用。</p><p><strong>需要注意：</strong></p><ol><li>css中的变量名是区分大小写的<code>--navColor</code>和<code>--navcolor</code>是两个不同的变量;</li><li>定义变量的时候<code>:</code>号和<code>;</code>中间是一个整体，整体是变量的值;</li><li>变量值也就是css的规则值，任何规则值都可以存入变量，并且变量值不用加引号;</li></ol><p><strong>兼容性：</strong><br><img src="/2020/05/21/CSS3/variables/custom-variables-caniuse.png" alt="image"></p><p><a href="https://caniuse.com/#search=--" rel="external nofollow noopener noreferrer" target="_blank">查看兼容详情</a></p><h2 id="变量使用"><a href="#变量使用" class="headerlink" title="变量使用"></a>变量使用</h2><blockquote><p>要想使用上边我们定义的变量，就要用到<code>var()</code>函数</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">  var( &lt;custom-variable-name&gt; , &lt;declaration-value&gt;? )</code></pre><p><strong>参数说明：</strong></p><ol><li><code>custom-variable-name</code>：必填，表示我们定义的变量名；</li><li><code>declaration-value</code>：可选，后补值，当自定义变量值不存在的情况下将使用这个值，他会将把自定义变量名后边的所有参数看成一个整体，所以这个值可以包含逗号<code>,</code>、空格<code></code>、括号<code>()</code>等css有效的规则值，他不能使用自定义变量名，不能有回车换行，不能有<code>;</code>。</li></ol><p><strong>实例：</strong></p><pre><code class="css">.nav{  color: var(--navColor);  padding: var(--navPadding);}selector{  font: var(--nameFont, normal 700 16px/ 30px &#39;黑体&#39;);  border: var(--boxBorder, 1px solid #c00);}</code></pre><p><strong>兼容性：</strong><br><img src="/2020/05/21/CSS3/variables/var-caniuse.png" alt="image"></p><p><a href="https://caniuse.com/#search=css%20var" rel="external nofollow noopener noreferrer" target="_blank">查看兼容详情</a></p><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><blockquote><p>上面我们提到过css的变量是有它的作用域的，在全局和布局同时定义了一个变量，会优先应用局部作用域。</p></blockquote><p><strong>代码说明：</strong></p><pre><code class="html">&lt;div class=&quot;div-1&quot;&gt;这里显示绿色文字&lt;/div&gt;&lt;div class=&quot;div-2&quot;&gt;这里显示红色文字&lt;/div&gt;&lt;div class=&quot;div-3&quot; style=&quot;--fontColor:blue;&quot;&gt;这里显示蓝色文字&lt;/div&gt;&lt;style&gt;:root{  --fontColor: red;}.div-1{  --fontColor: green;  /* 这里将应用绿色的文字样式，也就是自己定义的局部变量 */  color: var(--fontColor);}.div-2{  /* 这里将应用红色的文字样式，也就是根目录的变量 */  color: var(--fontColor);}.div-3{  /* 这里将应用蓝色的文字样式，也就是元素中style行内定义的变量 */  color: var(--fontColor);}&lt;/style&gt;</code></pre><h2 id="变量的优先级"><a href="#变量的优先级" class="headerlink" title="变量的优先级"></a>变量的优先级</h2><blockquote><p>css中应用变量时的优先级和css定义用选择器定义属性优先级差不多</p></blockquote><p><strong>代码说明：</strong></p><pre><code class="html">&lt;div class=&quot;box-1&quot; id=&quot;box&quot;&gt;  &lt;span class=&quot;span&quot;&gt;这里显示绿色文字&lt;span&gt;&lt;/div&gt;&lt;style&gt;:root{  --bgColor: red;}#box{  --bgColor: blue;}.box-1{  --bgColor: green;}.span{  --bgColor: purple;}.box-1{  /* 这里将应用蓝色的背景样式，也就是通过id定义的变量 */  background-color: var(--bgColor);}.span{  /* 这里将应用自色的背景样式，也就是通过自己class名定义的变量 */  background-color: var(--bgColor);}&lt;/style&gt;</code></pre><p>从上边代码可以看出，css获取变量和css的样式优先级一样，顺序是：<code>!important</code> &gt; <code>style=&quot;&quot;</code> &gt; <code>#id</code> &gt; <code>.class</code> &gt; <code>tagName</code> &gt; <code>:root</code>; 但是需要注意的是这里的<code>span</code>是先找自己定义作用域下的变量，如果没有才找父级作用域的变量，上边代码<code>span</code>自身定义的有变量，所以背景就是紫色。</p><p><strong>案例演示：</strong><a href="https://codepen.io/qwguo88/full/eYpXGGQ" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/eYpXGGQ</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="css-variables" src="https://codepen.io/qwguo88/embed/eYpXGGQ?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/eYpXGGQ" rel="external nofollow noopener noreferrer" target="_blank">css-variables</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="javascript中操作变量"><a href="#javascript中操作变量" class="headerlink" title="javascript中操作变量"></a>javascript中操作变量</h2><blockquote><p>css3中的变量我们也可以使用javascript来获取和操作它</p></blockquote><pre><code class="javascript">// 获取行内样式的变量名element.style.getPropertyValue(&quot;--variableName&quot;);// 获取样式表里定义的变量getComputedStyle(element).getPropertyValue(&quot;--variableName&quot;);// 设置变量的值element.style.setProperty(&quot;--variableName&quot;, value);</code></pre><h2 id="检测浏览器支持情况"><a href="#检测浏览器支持情况" class="headerlink" title="检测浏览器支持情况"></a>检测浏览器支持情况</h2><blockquote><p>我们可以通过css语法和javascript语法来检测浏览器是否支持css变量</p></blockquote><p>css通过<code>@supports</code>性能查询语法来检测</p><p><strong>语法：</strong></p><pre><code class="css">@supports (--a: 0){  .box{    background-color:#c00;  }}@supports(not(--a: 0)){  .box{    background-color:#cc0;  }}</code></pre><p><strong>js语法检测：</strong></p><pre><code class="javascript">const isSupported = window.CSS &amp;&amp; window.CSS.supports &amp;&amp; window.CSS.supports(&#39;--a&#39;, 0);if (isSupported) {  /* supported */} else {  /* not supported */}</code></pre><p><strong>参考链接：</strong></p><ol><li>阮一峰老师：<a href="http://www.ruanyifeng.com/blog/2017/05/css-variables.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.ruanyifeng.com/blog/2017/05/css-variables.html</a></li><li>google developers： <a href="https://developers.google.com/web/updates/2016/02/css-variables-why-should-you-care" rel="external nofollow noopener noreferrer" target="_blank">https://developers.google.com/web/updates/2016/02/css-variables-why-should-you-care</a></li><li>MDN：<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties" rel="external nofollow noopener noreferrer" target="_blank">https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
            <tag> variables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于css中文本的换行</title>
      <link href="/2020/05/12/CSS/textwrap/"/>
      <url>/2020/05/12/CSS/textwrap/</url>
      
        <content type="html"><![CDATA[<h1 id="关于css中换行的一些学习"><a href="#关于css中换行的一些学习" class="headerlink" title="关于css中换行的一些学习"></a>关于css中换行的一些学习</h1><p>在介绍之前我们先来看一下浏览器默认情况下文本的超出容器的处理情况：<br><strong>案例展示：</strong> <a href="https://codepen.io/qwguo88/full/RZMQgB" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/RZMQgB</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="textWrap_1.html" src="https://codepen.io/qwguo88/embed/RZMQgB?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/RZMQgB" rel="external nofollow noopener noreferrer" target="_blank">textWrap_1.html</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p>通过上边的例子可以看出：</p><ol><li>连续的数字不会自动换行；</li><li>连续的字母不会自动换行；</li><li>英文文章中空格是由<code>&amp;nbsp;</code>代码实现的空格不会换行；</li><li>英文单词不会在中间换行，在单词中间到达容器边缘，此单词会另起一行显示。</li><li>中文不会在文字和标点符号间换行，如果遇到标点符号到达容器的边缘，那么标点符号的前一个字会跟着折下来。</li><li>容器中是连续的图片的话会自动换行显示。</li></ol><blockquote><p>我们在处理一些文本超过容器的时候换行的问题。一般我们处理换行的css属于主要用到：</p></blockquote><h2 id="word-break"><a href="#word-break" class="headerlink" title="word-break"></a>word-break</h2><blockquote><p>用于设置浏览器处理自动换行的方式</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">word-break：normal | keep-all | break-all | break-word；</code></pre><p>字面理解：<code>word</code>单词的意思，<code>break</code>打破、间断的意思。连起来得意思就好理解了：单词和文本之间的间断方式。</p><ol><li><code>normal</code>：默认值，表示使用浏览器的默认的换行规则，依照亚洲语言和非亚洲语言的文本规则，允许在句内换行。</li><li><code>keep-all</code>：表示保持单词和句子的完成性，也就是说，英文中不会再单词内换行，中文不会在非标点符号内换行。</li></ol><p><strong>查看实例：</strong><a href="https://codepen.io/qwguo88/full/eYpKjqO" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/eYpKjqO</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="word-break:keep-all" src="https://codepen.io/qwguo88/embed/eYpKjqO?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/eYpKjqO" rel="external nofollow noopener noreferrer" target="_blank">word-break:keep-all</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><blockquote><p>个人测试：连续字母和数字不会自动折行<br>firefox 27.01版本的支持此属性。会使中文保持不换行，一直在一行显示。只有输入<br>强直换行，对英文貌似不起作用。<br>Ie6-11，利用ie11的调试模式进行测试的，对中文只有遇到标点符号后，后边的文字才能自动折行。<br>Chrome、Safari，对此属性不起作用，文字和normal效果一样，文字到容器边缘自动换行，单不会在标点符号内换行。</p></blockquote><ol start="3"><li><code>break-all</code>：(中断全部的) 该行为与亚洲语言的normal相同。也允许非亚洲语言文本行的任意字内断开。该值适合包含一些非亚洲文本的亚洲文本，比如使连续的英文字母间断行。</li></ol><p><strong>查看实例：</strong><a href="https://codepen.io/qwguo88/full/YzyvjJZ" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/YzyvjJZ</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="word-break:break-all" src="https://codepen.io/qwguo88/embed/YzyvjJZ?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/YzyvjJZ" rel="external nofollow noopener noreferrer" target="_blank">word-break:break-all</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><ol start="4"><li><code>break-word</code>：属性和下边的 <code>overflow-wrap:break-word</code>表现差不多，唯一的区别在表格连续英文字符串换行上，前者可以让表格单元格中的连续英文自动换行，后者不行。</li></ol><blockquote><p>个人测试：连续的字母和数字会自动折行<br>Firefox,chrome,safari等浏览器在中文和英文状态下显示效果一样当内容到达容器边缘都允许在标点符号和单词中间换行，允许标点符号在行首。<br>Ie6-11，等浏览器在中文和英文状态下显示效果一样当内容到达容器边缘也是允许单词和句子中间换行，但是他不允许标点符号在行首显示，如果内容到达边缘后第二行行首刚好是标点符号，他会让上一个单子尾字母或中文的汉子跟随标点符号一起换行。</p></blockquote><h2 id="word-wrap-和-overflow-wrap"><a href="#word-wrap-和-overflow-wrap" class="headerlink" title="word-wrap 和 overflow-wrap"></a>word-wrap 和 overflow-wrap</h2><blockquote><p>这个属性是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。<br>这里放到一起介绍的是因为 word-wrap 属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为 overflow-wrap 。 word-wrap 现在被当作 overflow-wrap 的 “别名”。 Chrome 和 Opera 浏览器都支持这种新语法。</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">/* old */word-wrap：normal | break-word；/* new */overflow-wrap: normal | break-word | anywhere;</code></pre><ol><li><code>normal</code>：默认值，允许内容顶开或溢出指定的容器边界，也就是长单词不换行</li><li><code>break-word</code>：在单词中间换行，当单词的长度超出了容器的长度是会在单词中间截断换到下一行显示。</li><li><code>anywhere</code>：</li></ol><blockquote><p>Web-kite,和ie各浏览器显示效果一样，允许连续的字母和数字等内容到达容器边缘后强直换行，和word-break:break-all的区别在于，word-wrap:break-word;不允许在英文单词间换行、标点符号在行首。word-break:break-all则允许英文单词间分开单词换行、标点符号在行首显示。但是ie下标点符号在行首显示不起作用。</p></blockquote><p><strong>案例展示：</strong><a href="https://codepen.io/qwguo88/full/ExVpgxj" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/ExVpgxj</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="overflow-wrap:break-word" src="https://codepen.io/qwguo88/embed/ExVpgxj?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/ExVpgxj" rel="external nofollow noopener noreferrer" target="_blank">overflow-wrap:break-word</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p>如果要在表格下让连续的字母或数字换行，使用<code>word-break:break-all;</code>可以达到换行目的但是相应的单词和标点符号会在中间折行。使用<code>word-wrap:break-word;</code>不起作用。解决方法是给表格定义<code>table-layout:fixed;</code><br><strong>提示：</strong></p><blockquote><p>当然在元素中使用了white-space:pre/nowrap的话，word-wrap:break-wrap和word-break:break-word;都将失去作用，使中文，英文都在同一行显示，不会换行.<br>在换行中有时还会涉及到：设置或检索对象内空格的处理方式。</p></blockquote><h2 id="white-space"><a href="#white-space" class="headerlink" title="white-space"></a>white-space</h2><blockquote><p>用于设置元素对象内空格的处理方式</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">white-space: normal | pre | nowrap | pre-wrap | pre-line | break-spaces；</code></pre><p><strong>取值说明：</strong></p><ol><li><code>normal</code>：浏览器的默认处理方式 连续的空白符会被合并，换行符会被当作空白符来处理 文本自动换行。</li><li><code>pre</code>： 用等宽字体显示预先格式化的文本，不合并文字间的空白距离，当文字超出边界时不换行，在遇到换行符或者<code>&lt;br&gt;</code>元素时才会换行。</li><li><code>nowrap</code>：强制在同一行内显示所有文本，合并文本间的多余空白，直到文本结束或者遭遇br对象。</li><li><code>pre-wrap</code>：用等宽字体显示预先格式化的文本，不合并文字间的空白距离，当文字碰到边界时发生换行。</li><li><code>pre-line</code>：保持文本的换行，不保留文字间的空白距离，当文字碰到边界时发生换行。</li><li><code>break-spaces</code>：</li></ol><p><strong>案例展示：</strong><a href="https://codepen.io/qwguo88/full/veZQvO" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/veZQvO</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="white-space" src="https://codepen.io/qwguo88/embed/veZQvO?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/veZQvO" rel="external nofollow noopener noreferrer" target="_blank">white-space</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p>当<code>white-sace</code>设置成<code>nowrap</code>的时候<code>word-break</code>和w<code>ord-wrap</code>设置换行的将都不生效。<br>当<code>white-space</code>设置成pre的时候<code>word-break</code>换行将不生效。<code>word-wrap</code>换行仅对文字和字符生效如果容器中是图片的话，图片将不换行。块级元素和行内块级元素显示效果一样。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> word-break </tag>
            
            <tag> word-wrap </tag>
            
            <tag> 文本换行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元素垂直居中的n种方法</title>
      <link href="/2020/04/29/CSS3/%E5%85%83%E7%B4%A0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84n%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2020/04/29/CSS3/%E5%85%83%E7%B4%A0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84n%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="元素垂直居中的n种方法"><a href="#元素垂直居中的n种方法" class="headerlink" title="元素垂直居中的n种方法"></a>元素垂直居中的n种方法</h1><blockquote><p>本文章收集了多种实现居中布局的方法，并且按照实现的时间线，从css2到css3的各种解决方案，从代码量有少到多的排序来一一说明每种布局方法的实现方式，通过阅读此文章能够让你解决平时的开发中遇到的各种布局问题。</p></blockquote><h2 id="使用line-height实现单行文本垂直居中"><a href="#使用line-height实现单行文本垂直居中" class="headerlink" title="使用line-height实现单行文本垂直居中"></a>使用line-height实现单行文本垂直居中</h2><blockquote><p><code>line-height</code>：用于设置多行元素的空间量，如多行文本的间距。对于块级元素，它指定元素行盒（line boxes）的最小高度。对于非替代的 inline 元素，它用于计算行盒（line box）的高度。</p></blockquote><pre><code class="css">.box-1{    height: 50px;    line-height: 50px;}</code></pre><pre><code class="html">&lt;div class=&quot;box box-1&quot;&gt;    这是要垂直居中的内容。&lt;/div&gt;</code></pre><p><strong>查看案例：</strong> <a href="https://codepen.io/qwguo88/full/dyYvBQv" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/dyYvBQv</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="vertical-middle-line-height" src="https://codepen.io/qwguo88/embed/dyYvBQv?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" loading="lazy"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/dyYvBQv" rel="external nofollow noopener noreferrer" target="_blank">vertical-middle-line-height</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="使用inline-block元素和vertical-align特性实现垂直居中"><a href="#使用inline-block元素和vertical-align特性实现垂直居中" class="headerlink" title="使用inline-block元素和vertical-align特性实现垂直居中"></a>使用inline-block元素和vertical-align特性实现垂直居中</h2><blockquote><p>此方法不限制元素的宽高，兼容性好</p></blockquote><ol><li><code>vertical-align</code>：用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。</li></ol><pre><code class="html">&lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;content&quot;&gt;        这是要垂直居中的内容。    &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.box{  text-align: center;  letter-spacing: -.3em;}.box::before{  content: &#39;&#39;;  height: 100%;  width: 1px;  margin-right: -1px;  display:inline-block;  vertical-align: middle;}.content{  display:inline-block;  vertical-align: middle;  letter-spacing: normal;}</code></pre><p><strong>查看案例：</strong> <a href="https://codepen.io/qwguo88/full/KKdmvdj" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/KKdmvdj</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="vertical-middle-inline-block" src="https://codepen.io/qwguo88/embed/KKdmvdj?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" loading="lazy"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/KKdmvdj" rel="external nofollow noopener noreferrer" target="_blank">vertical-middle-inline-block</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p>上面的案例通过利用<code>display:inline-block</code>的高度100%于父级高度，再利用<code>vertical-aling:middle</code>垂直居中属性，让行内块级元素剧中与父级。在元素设置成行内块级元素的时候代码中如果元素后边有空格，可以通过设置父级元素<code>letter-spacing:-.3em</code>，然后在通过居中元素还原文字间隔，或者通过设置父级的<code>font-size:0;</code>也可以取消空格的间距。其中红色竖线是通过父元素的伪类设置的。</p><h2 id="使用表格单元格和vertical-align特性实现垂直居中"><a href="#使用表格单元格和vertical-align特性实现垂直居中" class="headerlink" title="使用表格单元格和vertical-align特性实现垂直居中"></a>使用表格单元格和vertical-align特性实现垂直居中</h2><pre><code class="html">&lt;div class=&quot;box&quot;&gt;  &lt;div class=&quot;content&quot;&gt;    这是要垂直居中的内容。  &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.box{  display: table-cell;  vertical-align: middle;  text-align:center;}.content{  display:inline-block;}</code></pre><p>此方法需要设置父级的父级为<code>diaplay:table;</code>，并且设置父元素：<code>display:table-cell</code>，然后在设置<code>vertical-align:middle</code>，实现元素居中，但是此方法子元素需要是行内元素，和行内块级元素;</p><p><strong>查看案例：</strong> <a href="https://codepen.io/qwguo88/full/qBOmPaM" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/qBOmPaM</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="vertical-middle-table-cell" src="https://codepen.io/qwguo88/embed/qBOmPaM?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" loading="lazy"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/qBOmPaM" rel="external nofollow noopener noreferrer" target="_blank">vertical-middle-table-cell</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="使用绝对定位absolute和margin负值"><a href="#使用绝对定位absolute和margin负值" class="headerlink" title="使用绝对定位absolute和margin负值"></a>使用绝对定位absolute和margin负值</h2><blockquote><p>此方法用于固定宽高的元素，或者通过js获取不固定元素宽高</p></blockquote><pre><code class="html">&lt;div class=&quot;box&quot;&gt;  &lt;div class=&quot;content&quot;&gt;    这是要垂直居中的内容。  &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.box{  position: relative;}.content{  position: absolute;  width: 100px;  height: 100px;  left: 50%;  top: 50%;  margin: -50px 0 0 -50px;}</code></pre><p>此方法需要设置元素依照父级绝对定位，left和top都按照父元素50%定位。且需要知道要居中元素的宽高，也可以通过javascript获取元素的宽高，并且设置<code>margin</code>的上和左为负值元素宽高的一半；</p><h2 id="使用绝对定位absolute和margin-auto"><a href="#使用绝对定位absolute和margin-auto" class="headerlink" title="使用绝对定位absolute和margin:auto"></a>使用绝对定位absolute和margin:auto</h2><blockquote><p>此方法需要设置居中元素为固定宽高</p></blockquote><pre><code class="html">&lt;div class=&quot;box&quot;&gt;  &lt;div class=&quot;content&quot;&gt;    这是要垂直居中的内容。  &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.box{  position: relative;}.content{  position: absolute;  width: 100px;  height: 100px;  left: 0;  top: 0;  right: 0;  bottom: 0;  margin: auto;}</code></pre><p>此方法利用<code>margin: auto;</code>居中特性加决定定位上下左右为0来实现元素居中，此方法需要固定元素的宽高，并且决对定位于父元素。兼容ie8以上浏览器.</p><h2 id="使用绝对定位absolute和css3的transform-translate属性"><a href="#使用绝对定位absolute和css3的transform-translate属性" class="headerlink" title="使用绝对定位absolute和css3的transform:translate属性"></a>使用绝对定位absolute和css3的transform:translate属性</h2><pre><code class="html">&lt;div class=&quot;box&quot;&gt;  &lt;div class=&quot;content&quot;&gt;    这是要垂直居中的内容。  &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.box{  position: relative;}.content{  position: absolute;  left: 50%;  top: 50%;  transform:translate(-50%, -50%);}</code></pre><p>此方法利用了css3的新特性元素偏移属性，先让元素绝对定位于父元素的右、上的50%，然后通过<code>transform:translate(-50%, -50%);</code>设置元素按照自身的右上便宜50%实现居中，此方法不用的优点：不用固定元素宽高，缺点：兼容需要支持css3的浏览器。</p><p><strong>案例说明：</strong> <a href="https://codepen.io/qwguo88/full/jObmLaN" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/jObmLaN</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="vertical-middle-absolute-margin" src="https://codepen.io/qwguo88/embed/jObmLaN?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" loading="lazy"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/jObmLaN" rel="external nofollow noopener noreferrer" target="_blank">vertical-middle-absolute-margin</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="使用flex实现居中"><a href="#使用flex实现居中" class="headerlink" title="使用flex实现居中"></a>使用flex实现居中</h2><blockquote><p>通过flex弹性布局有好多种方式可以居中对齐，可以给父级单独设置，或者父级子级结合设置实现</p></blockquote><p><strong>html代码结构完全一样：</strong></p><pre><code class="html">&lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;content&quot;&gt;      这是要垂直居中的内容。    &lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><pre><code class="css">.box{    display: flex;    justify-content: center;    align-items: center;}</code></pre><p>最简单的方法，只通过父级设置，把父元素设置成弹性很模型，然后设置父元素的子元素横向纵向居中显示。</p><h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><pre><code class="css">.box{    display: flex;    justify-content: center;    align-content: center;    flex-wrap: wrap;}</code></pre><p>也是只通过父级设置，把父元素设置成弹性很模型，然后设置父元素的子元素横向居中显示，然后通过弹性很模型的子元素组<code>align-content:center</code>对齐方式，配合<code>flex-wrap:wrap</code>实现。</p><h3 id="方法3："><a href="#方法3：" class="headerlink" title="方法3："></a>方法3：</h3><pre><code class="css">.box{    display: flex;    flex-direction: column;    align-items: center;}.box:before{    content: &#39;&#39;;    flex-grow: .5;}</code></pre><p>这个也只只给父级设置，不同的是这个需要借助父级的伪元素；先把父元素设置成弹性很模型，然后设置纵向排列，然后设置横轴左右居中，然后再借助父元素伪类，设置纵向占据父元素的.5大小，实现上下居中。</p><h3 id="方法4："><a href="#方法4：" class="headerlink" title="方法4："></a>方法4：</h3><pre><code class="css">.box{    display: flex;}.content{    margin: auto;}</code></pre><p>把父元素设置成弹性很模型，然后通过要居中的子元素设置margin:auto，元素外间距依照父级自适应外间距。</p><h3 id="方法5："><a href="#方法5：" class="headerlink" title="方法5："></a>方法5：</h3><pre><code class="css">.box{    display: flex;    justify-content: center;}.content{    align-self: content}</code></pre><p>把父元素设置成弹性很模型，然后子元素设置align-self: content。</p><p><strong>查看案例：</strong> <a href="https://codepen.io/qwguo88/full/ZEbKgXG" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/ZEbKgXG</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="vertical-middle-flex" src="https://codepen.io/qwguo88/embed/ZEbKgXG?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" loading="lazy"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/ZEbKgXG" rel="external nofollow noopener noreferrer" target="_blank">vertical-middle-flex</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="使用grid网格布局实现居中"><a href="#使用grid网格布局实现居中" class="headerlink" title="使用grid网格布局实现居中"></a>使用grid网格布局实现居中</h2><blockquote><p>通过css的最新布局形式<code>grid</code>网格布局，也有多种方式，网格布局也可以给父级单独设置，或者父级子级结合设置实现</p></blockquote><p><strong>html代码结构完全一样：</strong></p><pre><code class="html">&lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;content&quot;&gt;      这是要垂直居中的内容。    &lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="方法1：-1"><a href="#方法1：-1" class="headerlink" title="方法1："></a>方法1：</h3><pre><code class="css">.box{    display: grid;    place-content: center;}</code></pre><h3 id="方法2：-1"><a href="#方法2：-1" class="headerlink" title="方法2："></a>方法2：</h3><pre><code class="css">.box{    display: grid;    place-items: center;}</code></pre><h3 id="方法3：-1"><a href="#方法3：-1" class="headerlink" title="方法3："></a>方法3：</h3><pre><code class="css">.box{    display: grid;    justify-content: center;    align-content: center;}</code></pre><h3 id="方法4：-1"><a href="#方法4：-1" class="headerlink" title="方法4："></a>方法4：</h3><pre><code class="css">.box{    display: grid;    justify-content: center;    align-items: center;}</code></pre><h3 id="方法5：-1"><a href="#方法5：-1" class="headerlink" title="方法5："></a>方法5：</h3><pre><code class="css">.box{    display: grid;}.content{    margin: auto;}</code></pre><h3 id="方法6："><a href="#方法6：" class="headerlink" title="方法6："></a>方法6：</h3><pre><code class="css">.box{    display: grid;    justify-content: center;}.content{    align-self: center;}</code></pre><p><strong>查看案例：</strong> <a href="https://codepen.io/qwguo88/full/PoPmJbo" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/PoPmJbo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="vertical-middle-grid" src="https://codepen.io/qwguo88/embed/PoPmJbo?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" loading="lazy"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/PoPmJbo" rel="external nofollow noopener noreferrer" target="_blank">vertical-middle-grid</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="使用calc-计算函数实现"><a href="#使用calc-计算函数实现" class="headerlink" title="使用calc()计算函数实现"></a>使用calc()计算函数实现</h2><blockquote><p>此方法需要固定高度</p></blockquote><pre><code class="html">&lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;content&quot;&gt;      这是要垂直居中的内容。    &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.content{    margin: auto;    position: relative;    width: 300px;    height: 100px;    top: calc((100% - 100px)/ 2);}</code></pre><p>首先设置固定宽高，利用<code>margin:auto</code>左右居中，然后通过<code>relative</code>定位<code>top</code>通过<code>calc()</code>函数计算，使用父级的100% 减去元素自身高度然后除以2，也就是总高度减去元素高度计算后的一半值，如果元素设置了边线和内边距需要相应的减掉。</p><h2 id="使用设置文字排布方向属性writing-mode实现"><a href="#使用设置文字排布方向属性writing-mode实现" class="headerlink" title="使用设置文字排布方向属性writing-mode实现"></a>使用设置文字排布方向属性writing-mode实现</h2><pre><code class="html">&lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;box-inner&quot;&gt;        &lt;div class=&quot;content&quot;&gt;          这是要垂直居中的内容。        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.box{    writing-mode: tb-lr;    writing-mode: vertical-lr;    text-align: center;}.box-inner{    width: 100%;    display: inline-block;    writing-mode: lr;    writing-mode: horizontal-tb;}.content{    display: inline-block;    text-align: left;}</code></pre><p>这个方法相对来说复杂一些，需要多加一个标签，首先给最外层改变排布方向为垂直排布，然后设置垂直居中；然后在里边一层再把排布方向设置回来，并且设置为行内块级元素宽度100%；最后让居中的元素设置成行内块级元素，文字对齐设置成左对齐实现。</p><p><strong>查看案例：</strong> <a href="https://codepen.io/qwguo88/full/GRpmMjV" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/GRpmMjV</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="vertical-middle-write-mode" src="https://codepen.io/qwguo88/embed/GRpmMjV?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" loading="lazy"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/GRpmMjV" rel="external nofollow noopener noreferrer" target="_blank">vertical-middle-write-mode</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
            <tag> CSS </tag>
            
            <tag> 垂直居中 </tag>
            
            <tag> layout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>console控制台输出语法使用</title>
      <link href="/2020/04/22/JavaScript/console/"/>
      <url>/2020/04/22/JavaScript/console/</url>
      
        <content type="html"><![CDATA[<h1 id="console使用"><a href="#console使用" class="headerlink" title="console使用"></a>console使用</h1><blockquote><p>我们在开发过程中经常会用到浏览器的控制台工具，来打印一些信息便于我们开发和调试，console对象为我们提供了很多的方法，能够使我们美化格式化打印的信息，对我们调试有所帮助。</p></blockquote><h2 id="console方法"><a href="#console方法" class="headerlink" title="console方法"></a>console方法</h2><h3 id="log"><a href="#log" class="headerlink" title="log()"></a>log()</h3><blockquote><p><code>log()</code>：方法是我们最常用的方法，他是直接在控制台打印我们要显示的内容</p></blockquote><p><strong>基本语法：</strong></p><pre><code class="javascript">console.log(obj1 [, obj2, ..., objN);console.log(msg [, subst1, ..., substN);console.log(&#39;String: %s, Int: %d,Float: %f, Object: %o&#39;, str, ints, floats, obj)console.log(`temp的值为: ${temp}`)</code></pre><p><strong>参数说明：</strong></p><ol><li><code>obj1...objN</code>：一个用于输出的 JavaScript 对象列表。其中每个对象会以字符串的形式按照顺序依次输出到控制台。</li><li><code>msg</code>：站位符，可以使用<code>console</code>提供的占位符来用后边的<code>substr1</code>参数进行替换。</li><li><code>subst1...substN</code>：用于替换占位符的javascript对象</li></ol><p><strong>案例：</strong></p><pre><code class="javascript">// 单个输出var a = &#39;这是一个消息&#39;;console.log(a); // 这是一个消息// 多个元素输出console.log(1, 2, 3); // 1 2 3// 使用占位符输出console.log(&#39;%d + %d = %d&#39;,1,2,3);  // 1 + 2 = 3// 使用不同类型的占位符var str = &quot;这是字符串&quot;;var ints = 40;var floats = 3.3;var obj = {a: 10, b: 20, c:[1, 3, 4], d:{x:10, y:10}};console.log(&#39;String: %s, Int: %d,Float: %f, Object: %o&#39;, str, ints, floats, obj);//String: 这是字符串, Int: 40,Float: 3.300000, Object: Object { a: 10, b: 20, c: (3) […], d: {…} }// 使用ES6的模版语法var temp = &#39;&lt;div&gt;这是一个div元素&lt;/div&gt;&#39;;console.log(`temp的值为: ${temp}`);</code></pre><h3 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h3><blockquote><p><code>assert()</code>：判断第一个参数的真假，<code>true</code> 不做任何处理，<code>false</code> 的话抛出异常并且在控制台输出相应信息，消息以红色警告的形式输出。</p></blockquote><p><strong>基本语法：</strong></p><pre><code class="javascript">console.assert(assertion, obj1 [, obj2, ..., objN]);console.assert(assertion, msg [, subst1, ..., substN]);</code></pre><p><strong>参数说明：</strong></p><ol><li><code>assertion</code>：一个布尔表达式。如果assertion为假，消息将会被输出到控制台之中。</li><li><code>obj1...objN</code>：被用来输出的Javascript对象列表，可以是一个或者多个用逗号分开。</li><li><code>msg</code>：站位符，可以使用<code>console</code>提供的占位符来用后边的<code>substr1</code>参数进行替换。</li><li><code>subst1...substN</code>：用于替换占位符的javascript对象</li></ol><p><strong>案例：</strong></p><pre><code class="javascript">var a = true;console.assert(a, &#39;为真的消息不会输出&#39;); // 因为第一个参数为真所以这段不会输出var b = false;console.assert(b, &#39;为假的消息输出&#39;); // 因为第一个参数为假所以输出‘Assertion failed: 为假的消息输出’//通过占位符输出消息console.assert(b, &#39;%s%s&#39;, &#39;my&#39;, &#39;e&#39;, &#39;you&#39;);  // Assertion failed: mye you</code></pre><h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><blockquote><p><code>clear()</code>：清楚控制台的所有消息，并且输出：<code>控制台已清除。</code>的消息。需要的注意的一点是在Google Chrome浏览器的控制台中，如果用户在设置中勾选了“Preserve log”选项，console.clear()将不会起作用。</p></blockquote><p><strong>语法：</strong></p><pre><code class="javascript">console.clear();</code></pre><h3 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h3><blockquote><p><code>count()</code>：以参数为标识记录调用的次数，调用时在控制台打印标识以及调用次数。</p></blockquote><p><strong>语法：</strong></p><pre><code class="javascript">console.count([label]);</code></pre><p><strong>参数说明：</strong></p><ol><li><code>label</code>：字符串类型，可选的标识参数，如果传入，则以此标识来记录调用测试。</li></ol><p><strong>案例：</strong></p><pre><code class="javascript">/*案例1*/// 定义一个标识变量var tag = &quot;&quot;;function fun() {    // 通过标识变量来记录调用次数    console.count(tag);}// 给标识变量赋值one,然后调用fun方法tag = &quot;one&quot;;fun(); // one: 1// 更改标识变量为twotag = &quot;two&quot;;fun(); // two: 1fun(); // two: 2console.count(&quot;three&quot;); // three: 1console.count(&quot;two&quot;); // two: 3/*案例2*/var abcDom = document.getElementById(&#39;abc&#39;);for(var i in abcDom){    // 通过这种方式可以知道abcDom中能够遍历的属性和方法总个数，当然也可以用其他方法，但是这里是演示的console.count的使用    console.count(&quot;dom&quot;);    console.log(i +&#39;---&gt;&#39;+abcDom[i]);}</code></pre><p><strong>案例1打印结果：</strong><br><img src="/2020/04/22/JavaScript/console/console.count_1.png" alt="image"></p><h3 id="countReset"><a href="#countReset" class="headerlink" title="countReset()"></a>countReset()</h3><blockquote><p>重置<code>count()</code>计数器，此函数有一个可选参数 label。如果提供了参数label，此函数会重置与label关联的计数为0。如果省略了参数，此函数会重置默认的计数器为0。</p></blockquote><p><strong>语法：</strong></p><pre><code class="javascript">console.countReset([label]);</code></pre><p><strong>参数说明：</strong></p><ol><li><code>label</code>：字符串类型，用于要重置计数器的标识符。</li></ol><p><strong>案例：</strong></p><pre><code class="javascript">/*案例1*/// 定义一个标识变量var tag = &quot;&quot;;function fun() {    // 通过标识变量来记录调用次数    console.count(tag);}// 给标识变量赋值one,然后调用fun方法tag = &quot;one&quot;;fun(); // one: 1fun(); // one: 2console.countReste(&#39;one&#39;);fun(); // one: 1console.count(); // default: 1console.count(); // default: 2console.countReste();console.count(); // default: 1</code></pre><h3 id="debug"><a href="#debug" class="headerlink" title="debug()"></a>debug()</h3><blockquote><p>输出“调试”级别的消息且仅仅控制台配置为显示调试输出时才显示该消息。此方法和<code>console.log()</code>方法基本一样。</p></blockquote><p><strong>语法：</strong></p><pre><code class="javascript">console.debug(对象1 [, 对象2, ..., 对象N]);console.debug(消息[, 字符串1, ..., 字符串N]);</code></pre><h3 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h3><blockquote><p>在控制台中显示指定JavaScript对象的属性，并通过类似文件树样式的交互列表显示。</p></blockquote><p><strong>语法：</strong></p><pre><code class="javascript">console.dir(object);</code></pre><p><strong>参数说明：</strong></p><ol><li><code>object</code>：打印出该对象的所有属性和属性值.</li></ol><p><strong>案例：</strong></p><pre><code class="javascript">var obj = {a: 10, b: 20, c:[10, 0, 30]};var arr = [10, 0, 30];/*HTML代码：&lt;div id=&quot;abc&quot;&gt;这是内容&lt;/div&gt;*/var abcDom = document.getElementById(&#39;abc&#39;);console.dir(obj); // Object  可以展开的Object形式console.dir(arr); // Array(3) 可以展开的数组形式console.dir(abcDom); // div#abc  可以展开的dom结构，包括dom所有的属性和方法</code></pre><p><strong>打印结果：</strong><br><img src="/2020/04/22/JavaScript/console/console.dir_1.png" alt="image"></p><p>可以看出<code>dir()</code>方法在打印对象数组的时候是先打印出类型，然后可以单击展开查看详细项，打印dom元素的时候打印出元素的所有属性和方法</p><h3 id="dirxml"><a href="#dirxml" class="headerlink" title="dirxml()"></a>dirxml()</h3><blockquote><p>显示一个明确的XML/HTML元素的包括所有后代元素的交互树。 如果无法作为一个element被显示，那么会以JavaScript对象的形式作为替代。 它的输出是一个继承的扩展的节点列表，可以让你看到子节点的内容。 <em>经过测试和console.log()输出基本相同</em>。</p></blockquote><p><strong>语法：</strong></p><pre><code class="javascript">console.dirxml(object);</code></pre><p><strong>参数说明：</strong></p><ol><li><code>object</code>：一个属性将被输出的JavaScript对象。</li></ol><h3 id="error-orexception"><a href="#error-orexception" class="headerlink" title="error()orexception()"></a>error()<code>or</code>exception()</h3><blockquote><p>向 Web 控制台输出一条错误消息，exception是error的别名它们功能相同。 <em>经过测试和console.log()输出相同，只是以淡红色背景警告的形式输出</em></p></blockquote><p><strong>语法：</strong></p><pre><code class="javascript">console.error(obj1 [, obj2, ..., objN]);console.error(msg [, subst1, ..., substN]);console.exception(obj1 [, obj2, ..., objN]);console.exception(msg [, subst1, ..., substN]);</code></pre><p><strong>参数说明：</strong></p><ol><li><code>obj1...objN</code>：一个用于输出的 JavaScript 对象列表。其中每个对象会以字符串的形式按照顺序依次输出到控制台。</li><li><code>msg</code>：站位符，可以使用<code>console</code>提供的占位符来用后边的<code>substr1</code>参数进行替换。</li><li><code>subst1...substN</code>：用于替换占位符的javascript对象</li></ol><h3 id="group"><a href="#group" class="headerlink" title="group()"></a>group()</h3><blockquote><p>在 Web控制台上创建一个新的分组.随后输出到控制台上的内容都会被添加一个缩进,表示该内容属于当前分组,直到调用console.groupEnd()之后,当前分组结束.</p></blockquote><p><strong>语法：</strong></p><pre><code class="javascript">console.group();</code></pre><p><strong>案例：</strong></p><pre><code class="javascript">// 定义一个分组console.group();// 后边的输出都会在这个分组内，并且有缩进，同时分组可以折叠起来console.error(obj);console.error(abcDom);console.log(obj);console.log(abcDom);</code></pre><h3 id="groupCollapsed"><a href="#groupCollapsed" class="headerlink" title="groupCollapsed()"></a>groupCollapsed()</h3><blockquote><p>在 Web控制台上创建一个新的分组.随后输出到控制台上的内容都会被添加一个缩进,表示该内容属于当前分组,直到调用console.groupEnd() 之后,当前分组结束.和 console.group()方法的不同点是,新建的分组默认是折叠的.用户必须点击一个按钮才能将折叠的内容打开.</p></blockquote><p><strong>语法：</strong></p><pre><code class="javascript">console.groupCollapsed();</code></pre><h3 id="groupEnd"><a href="#groupEnd" class="headerlink" title="groupEnd()"></a>groupEnd()</h3><blockquote><p>在 Web控制台中退出一格缩进(结束分组). 请参阅 console 中的Using groups in the console 来获取它的用法和示例.</p></blockquote><p><strong>语法：</strong></p><pre><code class="javascript">console.groupEnd();</code></pre><p><strong>综合案例：</strong></p><pre><code class="javascript">console.log(&quot;This is the outer level&quot;);// 开始最外层分组console.group(&quot;First group&quot;);console.log(&quot;In the first group&quot;);// 开始第二级分组console.group(&quot;Second group&quot;);console.log(&quot;In the second group&quot;);console.warn(&quot;Still in the second group&quot;);// 结束第二级分组console.groupEnd();console.log(&quot;Back to the first group&quot;);// 结束最外层分组console.groupEnd();console.debug(&quot;Back to the outer level&quot;);// 初始化合并的组console.groupCollapsed(&quot;First groupCollapsed&quot;);console.log(&quot;first child&quot;);console.log(&quot;second child&quot;);console.groupEnd();</code></pre><p><img src="/2020/04/22/JavaScript/console/console.group_1.png" alt="image"></p><h3 id="profile"><a href="#profile" class="headerlink" title="profile()"></a>profile()</h3><h3 id="table"><a href="#table" class="headerlink" title="table()"></a>table()</h3><blockquote><p>将数据以表格的形式显示。<br>这个方法需要一个必须参数 data，data 必须是一个数组或者是一个对象；还可以使用一个可选参数 columns。<br>它会把数据 data 以表格的形式打印出来。数组中的每一个元素（或对象中可枚举的属性）将会以行的形式显示在表格中。<br>表格的第一列是 index。如果数据 data 是一个数组，那么这一列的单元格的值就是数组的索引。 如果数据是一个对象，那么它们的值就是各对象的属性名称。 注意（在 FireFox 中）console.table 被限制为只显示1000行（第一行是被标记的索引。</p></blockquote><p><strong>语法：</strong></p><pre><code class="javascript">console.table(data [, columns]);</code></pre><p><strong>参数说明：</strong></p><ol><li><code>data</code>：要显示的数据。必须是数组或对象。</li><li><code>columns</code>：一个包含列的名称的数组。</li></ol><p><strong>案例：</strong></p><pre><code class="JavaScript">// 打印数组console.table([&quot;apples&quot;, &quot;oranges&quot;, &quot;bananas&quot;]);</code></pre><p><img src="/2020/04/22/JavaScript/console/console.table_1.png" alt="image"></p><pre><code class="JavaScript">// 打印对象console.table({&quot;apples&quot;:&quot;苹果&quot;, &quot;oranges&quot;:&quot;橙子&quot;, &quot;bananas&quot;:&quot;香蕉&quot;});</code></pre><p><img src="/2020/04/22/JavaScript/console/console.table_2.png" alt="image"></p><pre><code class="JavaScript">// 打印多维数组console.table([[&quot;apples&quot;,&quot;苹果&quot;], [&quot;oranges&quot;,&quot;橙子&quot;], [&quot;bananas&quot;,&quot;香蕉&quot;]]);</code></pre><p><img src="/2020/04/22/JavaScript/console/console.table_3.png" alt="image"></p><pre><code class="JavaScript">// 打印多维数组var obj = {  fruit:{  &quot;apples&quot;:&quot;苹果&quot;, &quot;oranges&quot;:&quot;橙子&quot;, &quot;bananas&quot;:&quot;香蕉&quot;, &quot;pair&quot;:&quot;梨&quot;  },  greens:{    &quot;cucumber&quot;:&quot;黄瓜&quot;, &quot;spinage&quot;:&quot;菠菜&quot;, &quot;potato&quot;:&quot;马铃薯&quot;  }};console.table(obj);</code></pre><p><img src="/2020/04/22/JavaScript/console/console.table_4.png" alt="image"></p><pre><code class="JavaScript">// 打印多维数组，并传入要打印的指定的值var obj = {  fruit:{    &quot;name&quot;:&quot;苹果&quot;, &quot;size&quot;:&quot;10cm&quot;, &quot;weight&quot;:&quot;500g&quot;, &quot;color&quot;:&quot;红色&quot;  },  greens: {    &quot;name&quot;:&quot;黄瓜&quot;, &quot;size&quot;:&quot;20cm&quot;, &quot;weight&quot;:&quot;20g&quot;, &quot;color&quot;: &quot;green&quot;  }};console.table(obj,[&#39;name&#39;, &#39;size&#39;]);</code></pre><p><img src="/2020/04/22/JavaScript/console/console.table_5.png" alt="image"></p><h3 id="tim"><a href="#tim" class="headerlink" title="tim()"></a>tim()</h3><blockquote><p>启动一个计时器来跟踪某一个操作的占用时长。每一个计时器必须拥有唯一的名字，页面中最多能同时运行10,000个计时器。当以此计时器名字为参数调用 console.timeEnd() 时，浏览器将以毫秒为单位，输出对应计时器所经过的时间。</p></blockquote><p><strong>语法：</strong></p><pre><code class="JavaScript">console.time(timerName);</code></pre><p><strong>参数说明：</strong></p><ol><li><code>timerName</code>：新计时器的名字。 用来标记这个计时器，作为参数调用 <code>console.timeEnd()</code> 可以停止计时并将经过的时间在终端中打印出来.</li></ol><h3 id="timeEnd"><a href="#timeEnd" class="headerlink" title="timeEnd()"></a>timeEnd()</h3><blockquote><p>停止一个通过 <code>console.time()</code> 启动的计时器</p></blockquote><p><strong>语法：</strong></p><pre><code class="JavaScript">console.timeEnd(label);</code></pre><p><strong>参数说明：</strong></p><ol><li><code>label</code>：需要停止的计时器名字。一旦停止，计时器所经过的时间会被自动输出到控制台。</li></ol><p><strong>案例展示：</strong></p><pre><code class="JavaScript">// 不传参数，开启一个默认default标识计数器console.time();for(var i=0;i&lt;1000000;i++){    var j=i*i;}// 不传参数，停止一个默认default标识计数器console.timeEnd();// 传参数，开启一个myTime参数的标识计数器var myTime = &#39;myTime&#39;;console.time(myTime);for(var i=0;i&lt;1000000;i++){    var j=i*i;}// 传入要停止的参数，停止myTime标识计数器console.timeEnd(myTime);</code></pre><p><img src="/2020/04/22/JavaScript/console/console.time_1.png" alt="image"></p><h3 id="trace"><a href="#trace" class="headerlink" title="trace()"></a>trace()</h3><blockquote><p>堆栈跟踪，控制台也支持输出堆栈，其将会显示到调用 console.trace() 的点的调用路径，个人理解就是从哪里调用的此方法：</p></blockquote><pre><code class="javascript">function foo(a) {    function bar(a) {        console.trace();    }    bar(10);}foo(20);</code></pre><p><img src="/2020/04/22/JavaScript/console/console.trace_1.png" alt="image"></p><h3 id="warn"><a href="#warn" class="headerlink" title="warn()"></a>warn()</h3><blockquote><p>以警告的方式输出消息</p></blockquote><pre><code class="javascript">var obj = {  fruit:{    &quot;name&quot;:&quot;苹果&quot;, &quot;size&quot;:&quot;10cm&quot;, &quot;weight&quot;:&quot;500g&quot;, &quot;color&quot;:&quot;红色&quot;  },  greens: {    &quot;name&quot;:&quot;黄瓜&quot;, &quot;size&quot;:&quot;20cm&quot;, &quot;weight&quot;:&quot;20g&quot;, &quot;color&quot;: &quot;green&quot;  }};console.warn(obj);</code></pre><p><img src="/2020/04/22/JavaScript/console/console.warn_1.png" alt="image"></p><h2 id="console的占位符"><a href="#console的占位符" class="headerlink" title="console的占位符"></a>console的占位符</h2><blockquote><p>还记得我们上面提道德的<code>msg</code>占位符吗，console为我们提供了一些实用的占位符，让我们来替换要想要的内容。</p></blockquote><table><thead><tr><th>占位符</th><th>描述</th></tr></thead><tbody><tr><td> %o or %O</td><td>打印 JavaScript 对象。主要是用来替换对象元素</td></tr><tr><td> %d or %i</td><td>打印整数。支持数字格式化。例如, console.log(“Foo %.2d”, 1.1) 表示给数字添加2个。</td></tr><tr><td> %s</td><td>打印字符串。</td></tr><tr><td> %f</td><td>打印浮点数。支持格式化，比如 console.log(“Foo %.2f”, 1.1) 会输出两位小数: Foo 1.10</td></tr><tr><td> %c</td><td>用于修饰输出结果的样式替换</td></tr></tbody></table><h3 id="o-和-O"><a href="#o-和-O" class="headerlink" title="%o 和 %O"></a>%o 和 %O</h3><blockquote><p>表示要替换的是javascript对象，如果替换的是非对象类型</p></blockquote><pre><code class="javascript">var obj = {&quot;name&quot;:&quot;黄瓜&quot;, &quot;size&quot;:&quot;20cm&quot;, &quot;weight&quot;:&quot;20g&quot;, &quot;color&quot;: &quot;green&quot;}var arr = [&quot;name&quot;,&quot;黄瓜&quot;, &quot;size&quot;,&quot;20cm&quot;];var num = 10;var str = &#39;这是字符串&#39;;console.log(&#39;这是输出的对象类型%o&#39;, obj);console.log(&#39;这是输出的数组类型%O&#39;, arr);console.log(&#39;这是输出的数值类型%o&#39;, num);console.log(&#39;这是输出的字符串类型%o&#39;, str);</code></pre><p><img src="/2020/04/22/JavaScript/console/console.msg_obj_1.png" alt="image"></p><p>经过测试发现这个占位符可以替换所有类型，比较javascript的类型都归属于对象类型</p><h3 id="d-和-i"><a href="#d-和-i" class="headerlink" title="%d 和 %i"></a>%d 和 %i</h3><blockquote><p>用于替换数值类型</p><pre><code class="javascript">var obj = {&quot;name&quot;:&quot;黄瓜&quot;, &quot;size&quot;:&quot;20cm&quot;, &quot;weight&quot;:&quot;20g&quot;, &quot;color&quot;: &quot;green&quot;}var arr = [&quot;name&quot;,&quot;黄瓜&quot;, &quot;size&quot;,&quot;20cm&quot;];var num = 10;var str = &#39;这是字符串&#39;;console.log(&#39;这是输出的对象类型%d&#39;, obj);console.log(&#39;这是输出的数组类型%i&#39;, arr);console.log(&#39;这是输出的数值类型%d&#39;, num);console.log(&#39;这是输出的字符串类型%i&#39;, str);console.log(&#39;这是输出的字符串类型%i&#39;, &#39;50&#39;);console.log(&#39;这是输出的字符串类型%d&#39;, &#39;50&#39;);console.log(&#39;这是输出的字符串类型%i&#39;, 50.35);console.log(&#39;这是输出的字符串类型%d&#39;, 50.35);</code></pre><p><img src="/2020/04/22/JavaScript/console/console.msg_num_1.png" alt="image"></p></blockquote><p>还是使用上边的代码输出结果就不一样了，非对象类型都将输出<code>NaN</code>，即便是字符串数值也不会强制转换，如果是小数将取整输出。</p><blockquote><p><code>%d</code> 和 <code>%i</code>还有另一种用法就是数字格式化，在数字前面加前导0或前导空格</p></blockquote><pre><code class="javascript">console.log(&quot;Foo %.2d&quot;, 1.1);console.log(&quot;Foo %4d&quot;, 4.100);console.log(&quot;Foo %.2i&quot;, 1.1);console.log(&quot;Foo %4i&quot;, 4.100);</code></pre><table><thead><tr><th>chrome</th><th>firefox</th></tr></thead><tbody><tr><td><img src="/2020/04/22/JavaScript/console/console.msg_num_2_chrome.png" alt="image"></td><td><img src="/2020/04/22/JavaScript/console/console.msg_num_2_firefox.png" alt="image"></td></tr></tbody></table><p>从输出结果可以看出，在<code>%</code>号后边增加<code>.</code>表示添加前导0，再跟多少位；在<code>%</code>后边直接跟数字表示加指定多少空位；此方法只有Firefox支持。</p><h3 id="f"><a href="#f" class="headerlink" title="%f"></a>%f</h3><blockquote><p>用于替换浮点类型数据</p></blockquote><pre><code class="javascript">var obj = {&quot;name&quot;:&quot;黄瓜&quot;, &quot;size&quot;:&quot;20cm&quot;, &quot;weight&quot;:&quot;20g&quot;, &quot;color&quot;: &quot;green&quot;}var arr = [&quot;name&quot;,&quot;黄瓜&quot;, &quot;size&quot;,&quot;20cm&quot;];var num = 10;var str = &#39;这是字符串&#39;;console.log(&#39;这是输出的对象类型%f&#39;, obj);console.log(&#39;这是输出的数组类型%f&#39;, arr);console.log(&#39;这是输出的数值类型%f&#39;, num);console.log(&#39;这是输出的字符串类型%f&#39;, str);console.log(&#39;这是输出的字符串类型%f&#39;, &#39;50&#39;);console.log(&#39;这是输出的字符串类型%f&#39;, &#39;50&#39;);console.log(&#39;这是输出的字符串类型%f&#39;, 50.35);console.log(&#39;这是输出的字符串类型%f&#39;, 50.35);</code></pre><p><img src="/2020/04/22/JavaScript/console/console.msg_f_1.png" alt="image"></p><p>从输出结果可以看出，它和，<code>%d</code> 和 <code>%i</code>基本一样，唯一的区别是他支持小数，同时非数值型数据将输出<code>NaN</code>;</p><h3 id="s"><a href="#s" class="headerlink" title="%s"></a>%s</h3><blockquote><p>用于替换字符串类型数据</p></blockquote><pre><code class="javascript">var obj = {&quot;name&quot;:&quot;黄瓜&quot;, &quot;size&quot;:&quot;20cm&quot;, &quot;weight&quot;:&quot;20g&quot;, &quot;color&quot;: &quot;green&quot;}var arr = [&quot;name&quot;,&quot;黄瓜&quot;, &quot;size&quot;,&quot;20cm&quot;];var num = 10;var str = &#39;这是字符串&#39;;console.log(&#39;这是输出的对象类型%s&#39;, obj);console.log(&#39;这是输出的数组类型%s&#39;, arr);console.log(&#39;这是输出的数值类型%s&#39;, num);console.log(&#39;这是输出的字符串类型%s&#39;, str);console.log(&#39;这是输出的字符串类型%s&#39;, &#39;50&#39;);console.log(&#39;这是输出的字符串类型%s&#39;, &#39;50&#39;);console.log(&#39;这是输出的字符串类型%s&#39;, 50.35);console.log(&#39;这是输出的字符串类型%s&#39;, 50.35);</code></pre><table><thead><tr><th>chrome</th><th>firefox</th></tr></thead><tbody><tr><td><img src="/2020/04/22/JavaScript/console/console.msg_str_1_chrome.png" alt="image"></td><td><img src="/2020/04/22/JavaScript/console/console.msg_str_1_firefox.png" alt="image"></td></tr></tbody></table><p>还是上边的代码，从输出结果可以看出，它把对象转换成<code>Object</code>，把数组转换成<code>Array(4)</code>，其他的都转换成字符串形式，火狐和谷歌输出结果不太相同;</p><h2 id="c-输出结果的样式修饰"><a href="#c-输出结果的样式修饰" class="headerlink" title="%c 输出结果的样式修饰"></a>%c 输出结果的样式修饰</h2><blockquote><p>在控制台中打印普通结果往往非常单调，有时候我们想让我们打印出的结果具有向css一样的样式修饰，可以使用占位符<code>%c</code>，在<code>%c</code>后面的结构将要使用我们定义的样式来修饰</p></blockquote><pre><code class="javascript">// 红色的文字console.log(&quot;%c这里输出红色文字&quot;, &quot;color: red; font-style: italic&quot;);// 给文字添加阴影，输出3D效果console.log(&quot;%c3D 文字效果&quot;, &quot; text-shadow: 0 1px 0 #ccc,0 2px 0 #c9c9c9,0 3px 0 #bbb,0 4px 0 #b9b9b9,0 5px 0 #aaa,0 6px 1px rgba(0,0,0,.1),0 0 5px rgba(0,0,0,.1),0 1px 3px rgba(0,0,0,.3),0 3px 5px rgba(0,0,0,.2),0 5px 10px rgba(0,0,0,.25),0 10px 10px rgba(0,0,0,.2),0 20px 20px rgba(0,0,0,.15);font-size:5em&quot;);// 输出一个渐变文字console.log(&#39;%c输出一个渐变文字 &#39;, &#39;background-image:-webkit-gradient( linear, left top, right top, color-stop(0, #f22), color-stop(0.15, #f2f), color-stop(0.3, #22f), color-stop(0.45, #2ff), color-stop(0.6, #2f2),color-stop(0.75, #2f2), color-stop(0.9, #ff2), color-stop(1, #f22) );color:transparent;-webkit-background-clip: text;font-size:5em;&#39;);//输出带背景的文字console.log(&#39;%c这是红色背景白色文字，%c这是红色文字蓝色背景&#39;, &#39;color: #fff; background: #f40; font-size: 24px;&#39;,&#39;color: #f00; background: #00f; font-size: 30px;&#39;);</code></pre><p>上面代码打印结果：</p><table><thead><tr><th>chrome</th><th>firefox</th></tr></thead><tbody><tr><td><img src="/2020/04/22/JavaScript/console/console.msg_c_1_chrome.png" alt="image"></td><td><img src="/2020/04/22/JavaScript/console/console.msg_c_1_firefox.png" alt="image"></td></tr></tbody></table><p>可以看出<code>%c</code>后边的文字将应用我们自定义的样式，如果我们一行要定义不同的文字样式，可以添加多个<code>%c</code>,然后后边的参数分别一一对应。</p><pre><code class="javascript">console.log(&#39;%c这是红色背景白色文字，%c这是红色文字蓝色背景&#39;, &#39;color: #fff; background: #f40; font-size: 24px;&#39;);console.log(&#39;%c这是红色背景白色文字，这是红色文字蓝色背景&#39;, &#39;color: #fff; background: #f40; font-size: 24px;&#39;,&#39;color: #f00; background: #00f; font-size: 30px;&#39;);</code></pre><table><thead><tr><th>chrome</th><th>firefox</th></tr></thead><tbody><tr><td><img src="/2020/04/22/JavaScript/console/console.msg_c_2_chrome.png" alt="image"></td><td><img src="/2020/04/22/JavaScript/console/console.msg_c_2_firefox.png" alt="image"></td></tr></tbody></table><p>上面结果可以看出，如果<code>%c</code>和传入的参数没有一一对应，那么浏览器解析的结果不一样。</p><p><code>%c</code> 语法可用的属性如下：</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>background</td><td>与其全写版本。</td></tr><tr><td>border</td><td>与其全写版本。</td></tr><tr><td>border-radius</td><td>圆角</td></tr><tr><td>box-decoration-break</td><td>？</td></tr><tr><td>box-shadow</td><td>元素的投影</td></tr><tr><td>clear 和 float</td><td>浮动</td></tr><tr><td>color</td><td>颜色</td></tr><tr><td>cursor</td><td>当前颜色</td></tr><tr><td>display</td><td>默认输出是inline，可以通过次数从改变元素</td></tr><tr><td>font 与其全写版本。</td><td>文字样式</td></tr><tr><td>line-height</td><td>文字行高</td></tr><tr><td>margin</td><td>外间距</td></tr><tr><td>outline 与其全写版本。</td><td>外边线</td></tr><tr><td>padding</td><td>内间距</td></tr><tr><td>text-transform 这类 text-* 属性</td><td>字母大小写</td></tr><tr><td>white-space</td><td>文字间距</td></tr><tr><td>word-spacing 和 word-break</td><td>文字是否换行</td></tr><tr><td>writing-mode</td><td>排布模式</td></tr></tbody></table><blockquote><p><strong>注意:</strong> 控制台信息的默认行为与行内元素相似。为了应用 padding, margin 这类效果，你应当这样设置display: inline-block。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> console </tag>
            
            <tag> 工具 </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过css3的scrollbar功能自定义浏览器的滚动条效果</title>
      <link href="/2020/04/16/CSS3/scrollbar/"/>
      <url>/2020/04/16/CSS3/scrollbar/</url>
      
        <content type="html"><![CDATA[<h1 id="webkit内核滚动条"><a href="#webkit内核滚动条" class="headerlink" title="webkit内核滚动条"></a>webkit内核滚动条</h1><blockquote><p>webkit内核的浏览器：chrome、safari、edge，因为自定义滚动条目前只有webkit内核的浏览器支持和FireFox支持部分功能，所以我们下边的属性都应用了<code>::-webkit-</code>前缀</p></blockquote><p><img src="/2020/04/16/CSS3/scrollbar/scrollbar.png" alt="image"></p><h2 id="滚动条属性选择器"><a href="#滚动条属性选择器" class="headerlink" title="滚动条属性选择器"></a>滚动条属性选择器</h2><p>这里我通过案例递增添加属性，我们可以通过下边的案例来理解各个属性指哪个位置</p><p><strong>案例：</strong><a href="https://codepen.io/qwguo88/full/bGVmmdQ" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/bGVmmdQ</a></p><iframe height="600" style="width: 100%;" scrolling="no" title="scrollbar" src="https://codepen.io/qwguo88/embed/bGVmmdQ?height=600&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/bGVmmdQ" rel="external nofollow noopener noreferrer" target="_blank">scrollbar</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h3 id="scrollbar"><a href="#scrollbar" class="headerlink" title="scrollbar"></a>scrollbar</h3><blockquote><p>设置滚动条整体部分样式，可以设置基本的css属性，包括，宽、高、背景颜色、边线等，这里需要注意的是设置高点的时候只对横线滚动条生效宽度为容器宽度，设置宽度的时候对纵向滚动条生效高度为容器高度。</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">::-webkit-scrollbar { styles }selector::-webkit-scrollbar{ styles }</code></pre><h3 id="scrollbar-button"><a href="#scrollbar-button" class="headerlink" title="scrollbar-button"></a>scrollbar-button</h3><blockquote><p>设置滚动条两端的按钮样式；</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">::-webkit-scrollbar-button { styles }selector::-webkit-scrollbar-button{ styles }</code></pre><p><strong>注意：</strong></p><ol><li>横向滚动条为左右按钮，可以设置宽度，当设置高度是，并不生效高度为总的滚动条高度；</li><li>纵向滚动条为上下按钮，可以设置高度，当设置宽度时也并不生效，它的宽度是总体滚动条的宽度；</li><li>如果想设置按钮和滚动条有间距并不会生效，可以设置边框再通过边框颜色透明方式实现外间距，但是这里背景绘制区域需要设置为<code>content-box</code>。</li></ol><h3 id="scrollbar-track"><a href="#scrollbar-track" class="headerlink" title="scrollbar-track"></a>scrollbar-track</h3><blockquote><p>设置滚动条外层轨道的样式，也就是两个按钮之间的区域。</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">::-webkit-scrollbar-track { styles }selector::-webkit-scrollbar-track{ styles }</code></pre><h3 id="scrollbar-track-piece"><a href="#scrollbar-track-piece" class="headerlink" title="scrollbar-track-piece"></a>scrollbar-track-piece</h3><blockquote><p>设置滚动条碎片的样式，也就是内层滚动槽的样式。</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">::-webkit-scrollbar-track-piece { styles }selector::-webkit-scrollbar-track-piece{ styles }</code></pre><h3 id="scrollbar-thumb"><a href="#scrollbar-thumb" class="headerlink" title="scrollbar-thumb"></a>scrollbar-thumb</h3><blockquote><p>设置滚动滑块的样式，也就是我们平时拖动的滚动条区域。</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">::-webkit-scrollbar-thumb { styles }selector::-webkit-scrollbar-thumb{ styles }</code></pre><h3 id="scrollbar-corner"><a href="#scrollbar-corner" class="headerlink" title="scrollbar-corner"></a>scrollbar-corner</h3><blockquote><p>设置横向和纵向滚动条相交的区域的边角样式。</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">::-webkit-scrollbar-corner { styles }selector::-webkit-scrollbar-corner{ styles }</code></pre><h3 id="scrollbar-resize"><a href="#scrollbar-resize" class="headerlink" title="scrollbar-resize"></a>scrollbar-resize</h3><blockquote><p>设置滚动条右下角拖动块的样式，这个设置我测试并不生效，如果需要显示拖动区域需要给元素设置<code>resize:both</code></p></blockquote><p><strong>语法：</strong></p><pre><code class="css">::-webkit-scrollbar-resize { styles }selector::-webkit-scrollbar-resize{ styles }</code></pre><h2 id="不同状态伪类"><a href="#不同状态伪类" class="headerlink" title="不同状态伪类"></a>不同状态伪类</h2><p><strong>案例：</strong> <a href="https://codepen.io/qwguo88/pen/QWjYwKd" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/pen/QWjYwKd</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="scrollbar-pseudo" src="https://codepen.io/qwguo88/embed/QWjYwKd?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/QWjYwKd" rel="external nofollow noopener noreferrer" target="_blank">scrollbar-pseudo</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h3 id="horizontal"><a href="#horizontal" class="headerlink" title=":horizontal"></a>:horizontal</h3><blockquote><p>水平伪类表示用来设置水平方向上的滚动条</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">::-webkit-scrollbar:horizontal { styles }selector::-webkit-scrollbar:horizontal{ styles }</code></pre><h3 id="vertical"><a href="#vertical" class="headerlink" title=":vertical"></a>:vertical</h3><blockquote><p>垂直伪类表示用来设置垂直方向上的滚动条</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">::-webkit-scrollbar:vertical { styles }selector::-webkit-scrollbar:vertical{ styles }</code></pre><h3 id="decrement"><a href="#decrement" class="headerlink" title=":decrement"></a>:decrement</h3><blockquote><p>适用于按钮和轨道碎片。表示递减的按钮或轨道碎片，例如可以使区域向上或者向右移动的区域和按钮</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">::-webkit-scrollbar-(button | track):decrement { styles }selector::-webkit-scrollbar-(button | track):decrement{ styles }</code></pre><p><strong>这里说明一下：</strong><code>decrement</code>：应用到按钮设置的时候表示：横向按钮的左按钮，纵向按钮的上按钮，应用在轨道碎片上：横向表示碎片上半部分，纵向表示碎片左半部分</p><h3 id="increment"><a href="#increment" class="headerlink" title=":increment"></a>:increment</h3><blockquote><p>适用于按钮和轨道碎片。表示递增的按钮或轨道碎片，例如可以使区域向下或者向左移动的区域和按钮</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">::-webkit-scrollbar-(button | track):increment { styles }selector::-webkit-scrollbar-(button | track):increment{ styles }</code></pre><p><strong>这里说明一下：</strong><code>increment</code>：应用到按钮设置的时候表示：横向按钮的右按钮，纵向按钮的下按钮，应用在轨道碎片上：横向表示碎片下半部分，纵向表示碎片右半部分</p><h3 id="start"><a href="#start" class="headerlink" title=":start"></a>:start</h3><blockquote><p>适用于按钮和轨道碎片。表示对象（按钮轨道碎片）的前一个，他和上边的<code>:decrement</code>效果一样</p></blockquote><h3 id="end"><a href="#end" class="headerlink" title=":end"></a>:end</h3><blockquote><p>适用于按钮和轨道碎片。表示对象（按钮轨道碎片）的后一个，他和上边的<code>:increment</code>效果一样</p></blockquote><h3 id="double-button"><a href="#double-button" class="headerlink" title=":double-button"></a>:double-button</h3><blockquote><p>适用于按钮和轨道碎片。判断轨道结束的位置是否是一对按钮。也就是轨道碎片紧挨着一对在一起的按钮。<del>没测试出来</del></p></blockquote><h3 id="single-button"><a href="#single-button" class="headerlink" title=":single-button"></a>:single-button</h3><blockquote><p>适用于按钮和轨道碎片。判断轨道结束的位置是否是一个按钮。也就是轨道碎片紧挨着一个单独的按钮。<del>没测试出来</del></p></blockquote><h3 id="no-button"><a href="#no-button" class="headerlink" title=":no-button"></a>:no-button</h3><blockquote><p>表示轨道结束的位置没有按钮。<del>没测试出来</del></p></blockquote><h3 id="corner-present"><a href="#corner-present" class="headerlink" title=":corner-present"></a>:corner-present</h3><blockquote><p>表示滚动条的角落是否存在。<del>测试的是会覆盖原有的样式，不知道什么意思</del></p></blockquote><h3 id="window-inactive"><a href="#window-inactive" class="headerlink" title=":window-inactive"></a>:window-inactive</h3><blockquote><p>适用于所有滚动条，表示包含滚动条的区域，焦点不在该窗口的时候。</p></blockquote><pre><code class="css">::-webkit-scrollbar-thumb:window-inactive{ styles }selector::-webkit-scrollbar-thumb:window-inactive{ styles }</code></pre><h3 id="enabled"><a href="#enabled" class="headerlink" title=":enabled"></a>:enabled</h3><blockquote><p>表示当前滚动条激活状态的样式。</p></blockquote><h3 id="disabled"><a href="#disabled" class="headerlink" title=":disabled"></a>:disabled</h3><blockquote><p>表示滚动条禁用的样式。</p></blockquote><h3 id="hover"><a href="#hover" class="headerlink" title=":hover"></a>:hover</h3><blockquote><p>表示当鼠标方式去的滚动条各属性的样式。</p></blockquote><h3 id="active"><a href="#active" class="headerlink" title=":active"></a>:active</h3><blockquote><p>表示鼠标按下时滚动条个属性的样式。</p></blockquote><h1 id="FireFox浏览器"><a href="#FireFox浏览器" class="headerlink" title="FireFox浏览器"></a>FireFox浏览器</h1><p><em>案例需要使用<code>Firefox</code>浏览器查看效果</em></p><p><strong>展示案例：</strong> <a href="https://codepen.io/qwguo88/full/zYvMzVJ" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/zYvMzVJ</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="firefox-scrollbar" src="https://codepen.io/qwguo88/embed/zYvMzVJ?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/zYvMzVJ" rel="external nofollow noopener noreferrer" target="_blank">firefox-scrollbar</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h3 id="scrollbar-width"><a href="#scrollbar-width" class="headerlink" title="scrollbar-width"></a>scrollbar-width</h3><blockquote><p>用来设置滚动条出现时的厚度，横向滚动条设置高度，纵向滚动条设置的是高度。</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">div{  scrollbar-width: none | auto | thin;}</code></pre><p><strong>参数说明：</strong></p><ol><li><code>none</code>：不显示滚动条，但是dom元素任然可以正常滚动。</li><li><code>auto</code>：默认值，表示走浏览器默认的样式。</li><li><code>thin</code>：比默认的滚动条要小一些，横向的变低，纵向的变窄。</li></ol><h3 id="scrollbar-color"><a href="#scrollbar-color" class="headerlink" title="scrollbar-color"></a>scrollbar-color</h3><blockquote><p>用来设置滚动条的颜色</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">div{  scrollbar-color: thumbColor trackColor;}</code></pre><p><strong>参数说明：</strong></p><ol><li><code>thumbColor</code>：用来设置滚动条拖动的滑块颜色。</li><li><code>trackColor</code>：用来设置滚动条轨道的颜色。</li></ol><!-- ## Internet Explorer(IE) --><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://css-tricks.com/custom-scrollbars-in-webkit/" rel="external nofollow noopener noreferrer" target="_blank">https://css-tricks.com/custom-scrollbars-in-webkit/</a></li><li><a href="https://webkit.org/blog/363/styling-scrollbars/" rel="external nofollow noopener noreferrer" target="_blank">https://webkit.org/blog/363/styling-scrollbars/</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/scrollbar-width" rel="external nofollow noopener noreferrer" target="_blank">https://developer.mozilla.org/zh-CN/docs/Web/CSS/scrollbar-width</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
            <tag> scrollbar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cropper.js 图片处理插件</title>
      <link href="/2020/03/26/jQuery/plugins/cropper/"/>
      <url>/2020/03/26/jQuery/plugins/cropper/</url>
      
        <content type="html"><![CDATA[<h1 id="图片剪裁插件Image-Cropper使用方法"><a href="#图片剪裁插件Image-Cropper使用方法" class="headerlink" title="图片剪裁插件Image Cropper使用方法"></a>图片剪裁插件Image Cropper使用方法</h1><blockquote><p>cropper是一款使用简单且功能强大的图片剪裁jQuery插件。该图片剪裁插件支持图片放大缩小，支持鼠标滚轮操作，支持图片旋转，支持触摸屏设备，支持canvas，并且支持跨浏览器使用。</p><ul><li>支持Promise API。</li><li>支持移动触摸事件。</li><li>基于canvas技术，支持canvas的浏览器都可以使用该插件。</li><li>通过Base64编码导出剪裁后的图片。</li><li>可以通过json数据来获取图片的位置和大小。</li><li>可以通过json数据来设置图片的位置和大小。</li><li>可以通过URL来获取图片。</li></ul></blockquote><h2 id="下载使用"><a href="#下载使用" class="headerlink" title="下载使用"></a>下载使用</h2><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul><li>官网：<a href="https://github.com/fengyuanchen/cropper" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/fengyuanchen/cropper</a></li><li>演示地址：<a href="https://fengyuanchen.github.io/cropper/" rel="external nofollow noopener noreferrer" target="_blank">https://fengyuanchen.github.io/cropper/</a></li><li>衍生产品-<em>Photo Editor</em>：<a href="https://fengyuanchen.github.io/photo-editor/" rel="external nofollow noopener noreferrer" target="_blank">https://fengyuanchen.github.io/photo-editor/</a></li></ul><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><pre><code class="shell"># 可以使用npm下载npm install cropper jquery# 通过bower安装$ bower install cropper jquery# 通过yarn安装$ yarn add cropper jquery</code></pre><h3 id="引入文件"><a href="#引入文件" class="headerlink" title="引入文件"></a>引入文件</h3><pre><code class="html">&lt;!-- 引入css样式 --&gt;&lt;link  href=&quot;cropper.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;!-- 引入js文件 --&gt;&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;cropper.js&quot;&gt;&lt;/script&gt;</code></pre><h3 id="构建html"><a href="#构建html" class="headerlink" title="构建html"></a>构建html</h3><pre><code class="html">&lt;!-- 可以将图片或canvas直接包裹到一个块级元素中 --&gt;&lt;div class=&quot;container&quot;&gt;  &lt;img id=&quot;image&quot; src=&quot;picture.jpg&quot;&gt;&lt;/div&gt;</code></pre><h3 id="设置样式"><a href="#设置样式" class="headerlink" title="设置样式"></a>设置样式</h3><pre><code class="css">/* 给container元素设置宽高 并且限制图片的宽避免图片溢出容器 */.container{  width: 500px;  height: 500px;}.container img {  max-width: 100%;}</code></pre><h3 id="初始化插件。"><a href="#初始化插件。" class="headerlink" title="初始化插件。"></a>初始化插件。</h3><pre><code class="javascript">// jquery获取元素var $image = $(&#39;#image&#39;);// 通过jquery Dom 的cropper方法初始化$image.cropper({  aspectRatio: 16 / 9,  crop: function(event) {    console.log(event.detail.x);    console.log(event.detail.y);    console.log(event.detail.width);    console.log(event.detail.height);    console.log(event.detail.rotate);    console.log(event.detail.scaleX);    console.log(event.detail.scaleY);  }});// 可以通过Dom对象的data的cropper属性获取初始化后获取Cropper.js实例var cropper = $image.data(&#39;cropper&#39;);</code></pre><h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><h3 id="参数-options"><a href="#参数-options" class="headerlink" title="参数(options)"></a>参数(options)</h3><blockquote><p>在调用cropper方法的时候我们可以传递可选的参数选项options，也可以通过setDefaults(options)设置选项，cropper支持39个可选属性</p></blockquote><pre><code class="javascript">$(&#39;img&#39;).cropper(options);// or// 设置全局cropper属性$.fn.cropper.setDefaults(options)// 参数项说明options = {  viewMode: 0,  dragMode: DRAG_MODE_CROP,  initialAspectRatio: NaN,  aspectRatio: NaN,  data: null,  preview: &#39;&#39;,  responsive: true,  restore: true,  checkCrossOrigin: true,  checkOrientation: true,  modal: true,  guides: true,  center: true,  highlight: true,  background: true,  autoCrop: true,  autoCropArea: 0.8,  movable: true,  rotatable: true,  scalable: true,  zoomable: true,  zoomOnTouch: true,  zoomOnWheel: true,  wheelZoomRatio: 0.1,  cropBoxMovable: true,  cropBoxResizable: true,  toggleDragModeOnDblclick: true,  minCanvasWidth: 0,  minCanvasHeight: 0,  minCropBoxWidth: 0,  minCropBoxHeight: 0,  minContainerWidth: 200,  minContainerHeight: 100,  ready: null,  cropstart: null,  cropmove: null,  cropend: null,  crop: null,  zoom: null}</code></pre><h4 id="viewMode"><a href="#viewMode" class="headerlink" title="viewMode"></a>viewMode</h4><blockquote><p> 定义裁切器的查看模式。如果设置<code>viewMode</code>为<code>0</code>，裁切框可以画布外的延伸，而设置值<code>1</code>，<code>2</code>或<code>3</code>将限制裁切框画布的大小。将<code>viewMode</code>设置成<code>2</code>或<code>3</code>将限制画布大小不超过容器大小。请注意，如果画布和容器的比例相同，则<code>2</code>和<code>3</code>之间没有区别。</p></blockquote><ul><li>类型： <code>Number</code></li><li>默认： <code>0</code></li><li>选项：<ul><li>0：无限制</li><li>1：限制裁切框不要超过图片的大小, 图片可以小于容器框。</li><li>2：限制裁切框不能超出图片的范围，且图片填充模式为 cover 最长边填充满容器，有短边填充不满的情况</li><li>3：限制裁切框不能超出图片的范围，且图片填充模式为 contain 最短边填充，最短边填充，有长边超出的现象</li></ul></li></ul><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td><img src="/2020/03/26/jQuery/plugins/cropper/viewMode_0.jpg" alt="image"></td><td><img src="/2020/03/26/jQuery/plugins/cropper/viewMode_1.jpg" alt="image"></td><td><img src="/2020/03/26/jQuery/plugins/cropper/viewMode_2.jpg" alt="image"></td><td><img src="/2020/03/26/jQuery/plugins/cropper/viewMode_3.jpg" alt="image"></td></tr></tbody></table><h4 id="dragMode"><a href="#dragMode" class="headerlink" title="dragMode"></a>dragMode</h4><blockquote><p>定义裁切器的拖动模式</p></blockquote><ul><li>类型： <code>string</code></li><li>默认：<code>crop</code></li><li>选项：<ul><li><code>crop</code>：创建一个新的裁切框, 图片不能移动</li><li><code>move</code>：不从新创建裁切框，可以拖动图片位置，这个时候需要确保<code>movable</code>属性设置为<code>true</code></li><li><code>none</code>：不从新创建裁切框，也不能拖动图片</li></ul></li></ul><h4 id="initialAspectRatio"><a href="#initialAspectRatio" class="headerlink" title="initialAspectRatio"></a>initialAspectRatio</h4><blockquote><p>定义裁切框的初始宽高比。默认情况下，它与画布（图像包装器）的纵横比相同。<em>这个值只有在<code>aspectRatio</code>值不进行设置的时候生效</em></p></blockquote><ul><li>类型： <code>Number</code> <em>可以是数字，或者数学计算公式如16/9、4/3</em></li><li>默认： <code>NaN</code></li></ul><h4 id="aspectRatio"><a href="#aspectRatio" class="headerlink" title="aspectRatio"></a>aspectRatio</h4><blockquote><p>定义裁切框的可拖动的长宽比。默认情况下是自由拖动，设置后将按照设置比例缩放大小</p></blockquote><ul><li>类型： <code>Number</code> <em>可以是数字，或者数学计算公式如16/9、4/3</em></li><li>默认： <code>NaN</code> 自由比例</li></ul><h4 id="data"><a href="#data" class="headerlink" title="data"></a>data</h4><blockquote><p>定义初始化裁切框的位置，大小等信息</p></blockquote><ul><li>类型：<code>object</code></li><li>默认：’’</li></ul><h4 id="preview"><a href="#preview" class="headerlink" title="preview"></a>preview</h4><blockquote><p>指定额外的dom元素（容器）以进行选择区域预览效果，元素或元素数组或节点列表对象或Document.querySelectorAll的有效选择器。</p></blockquote><ul><li>类型： <code>Element</code>：dom元素、<code>Array</code>：多个dom元素的数组形式，<code>nodeList</code>：dom列表，<code>String</code> dom的选择器，可以是<code>#id</code>、<code>.class</code>、<code>标签名</code>等</li><li>默认： <code>&#39;&#39;</code> 没有任何元素</li><li>注意：<ul><li>一定要设置元素的宽度和高度。</li><li>如果设置了<code>aspectRatio</code>属性的话最好按照这个比例设置宽高。</li><li>并且给元素设置<code>overflow:hidden</code>让元素多余截取隐藏</li></ul></li></ul><p>效果展示：可以同时添加多个预览元素<br><img src="/2020/03/26/jQuery/plugins/cropper/preview.jpg" alt="image"></p><h4 id="responsive"><a href="#responsive" class="headerlink" title="responsive"></a>responsive</h4><blockquote><p>在调整窗口大小的时候是否重新渲染裁切区域</p></blockquote><ul><li>类型：<code>Boolean</code></li><li>默认：<code>true</code></li></ul><h4 id="restore"><a href="#restore" class="headerlink" title="restore"></a>restore</h4><blockquote><p>在调整完窗口大小后，恢复裁切区域</p></blockquote><ul><li>类型：<code>Boolean</code></li><li>默认：<code>true</code></li></ul><h4 id="checkCrossOrigin"><a href="#checkCrossOrigin" class="headerlink" title="checkCrossOrigin"></a>checkCrossOrigin</h4><blockquote><p>检查当前图像是否是跨源图像。<br>如果是这样，则在克隆图像时，crossOrigin会将属性添加到克隆的图像元素，<em>并将时间戳添加到该src属性以重新加载源图像，以避免浏览器缓存错误</em>。<br>通过向crossOrigin图像元素添加属性将停止向图像URL添加时间戳并停止重新加载图像，但是读取图像数据以进行方向检查的请求（XMLHttpRequest）将需要一个时间戳来破坏缓存，以免现在浏览器缓存出错，您可以设置取消此请求的checkOrientation选项false。<br>如果图像的crossOrigin属性值为”use-credentials”，则当XMLHttpRequest读取图像数据时，该withCredentials属性将设置为true。。</p></blockquote><ul><li>类型：<code>Boolean</code></li><li>默认：<code>true</code></li></ul><h4 id="checkOrientation"><a href="#checkOrientation" class="headerlink" title="checkOrientation"></a>checkOrientation</h4><blockquote><p>检查当前图像的Exif方向信息。请注意，只有JPEG图像可以包含Exif方向信息。用于在旋转或翻转图像时做一些处理，以避免在iOS设备上一些问题。<br>此属性需要同时将<code>rotatable</code>和<code>scalable</code>选项设置为<code>true</code>才生效。</p></blockquote><ul><li>类型：<code>Boolean</code></li><li>默认：<code>true</code></li></ul><h4 id="modal"><a href="#modal" class="headerlink" title="modal"></a>modal</h4><blockquote><p>是否在裁切框的下方显示半透明的黑色遮罩。<em>当设置为<code>false</code>遮罩的dom元素是一直显示的只是把元素设置成透明</em></p></blockquote><ul><li>类型：<code>Boolean</code></li><li>默认：<code>true</code></li></ul><table><thead><tr><th>true</th><th>false</th></tr></thead><tbody><tr><td><img src="/2020/03/26/jQuery/plugins/cropper/modal_true.jpg" alt="image"></td><td><img src="/2020/03/26/jQuery/plugins/cropper/modal_false.jpg" alt="image"></td></tr></tbody></table><h4 id="guides"><a href="#guides" class="headerlink" title="guides"></a>guides</h4><blockquote><p>在裁切框中是否显示网格</p></blockquote><ul><li>类型：<code>Boolean</code></li><li>默认：<code>true</code></li></ul><table><thead><tr><th>true</th><th>false</th></tr></thead><tbody><tr><td><img src="/2020/03/26/jQuery/plugins/cropper/guides_true.jpg" alt="image"></td><td><img src="/2020/03/26/jQuery/plugins/cropper/guides_false.jpg" alt="image"></td></tr></tbody></table><h4 id="center"><a href="#center" class="headerlink" title="center"></a>center</h4><blockquote><p>在裁切框中是否显示中心控制器，也就是中间的小加号</p></blockquote><ul><li>类型：<code>Boolean</code></li><li>默认：<code>true</code></li></ul><table><thead><tr><th>true</th><th>false</th></tr></thead><tbody><tr><td><img src="/2020/03/26/jQuery/plugins/cropper/center_true.jpg" alt="image"></td><td><img src="/2020/03/26/jQuery/plugins/cropper/center_false.jpg" alt="image"></td></tr></tbody></table><h4 id="highlight"><a href="#highlight" class="headerlink" title="highlight"></a>highlight</h4><blockquote><p>是否高亮显示裁切框中的图片，查看源码后发现，也就是在上边添加了一个白色背景的dom元素，并且透明度设置为0.1看上去有点变亮的感觉</p></blockquote><ul><li>类型：<code>Boolean</code></li><li>默认：<code>true</code></li></ul><table><thead><tr><th>true</th><th>false</th></tr></thead><tbody><tr><td><img src="/2020/03/26/jQuery/plugins/cropper/highlight_true.jpg" alt="image"></td><td><img src="/2020/03/26/jQuery/plugins/cropper/highlight_false.jpg" alt="image"></td></tr></tbody></table><h4 id="background"><a href="#background" class="headerlink" title="background"></a>background</h4><blockquote><p>是否显示容器的网格背景，这个在<code>viewMode</code>模式设置成非3时可以看到效果</p></blockquote><ul><li>类型：<code>Boolean</code></li><li>默认：<code>true</code></li></ul><table><thead><tr><th>true</th><th>false</th></tr></thead><tbody><tr><td><img src="/2020/03/26/jQuery/plugins/cropper/background_true.jpg" alt="image"></td><td><img src="/2020/03/26/jQuery/plugins/cropper/background_false.jpg" alt="image"></td></tr></tbody></table><h4 id="autoCrop"><a href="#autoCrop" class="headerlink" title="autoCrop"></a>autoCrop</h4><blockquote><p>是否自动创建裁切框，默认自动创建，如果有<code>data</code>属性按照<code>data</code>给定的数据创建，如果没有，按照图片的宽高比创建合适的裁切框<br>如果设置<code>false</code>, 不自动创建，在<code>dragMode</code>属性设置为：<code>crop</code>的情况下可以拖动创建裁切框，其他值不能拖动创建</p></blockquote><ul><li>类型：<code>Boolean</code></li><li>默认：<code>true</code></li></ul><h4 id="autoCropArea"><a href="#autoCropArea" class="headerlink" title="autoCropArea"></a>autoCropArea</h4><blockquote><p>定义自动裁切区域的大小，取0到1之间的数字。（百分比）。</p></blockquote><ul><li>类型：<code>Number</code></li><li>默认：<code>0.8</code>(取图像的80%)</li></ul><h4 id="movable"><a href="#movable" class="headerlink" title="movable"></a>movable</h4><blockquote><p>定义图片是否可以拖动移动</p></blockquote><ul><li>类型：<code>Boolean</code></li><li>默认：<code>true</code></li></ul><h4 id="rotatable"><a href="#rotatable" class="headerlink" title="rotatable"></a>rotatable</h4><blockquote><p>是否开启图片旋转功能，默认开启</p></blockquote><ul><li>类型: <code>Boolean</code></li><li>默认: <code>true</code></li></ul><h4 id="scalable"><a href="#scalable" class="headerlink" title="scalable"></a>scalable</h4><blockquote><p>是否开启图片缩放功能，默认开启</p></blockquote><ul><li>类型: <code>Boolean</code></li><li>默认: <code>true</code></li></ul><h4 id="zoomable"><a href="#zoomable" class="headerlink" title="zoomable"></a>zoomable</h4><blockquote><p>是否开启图片可缩放功能，默认开启，如果关闭后，鼠标滚轮，和触摸放大缩小将不可用</p></blockquote><ul><li>类型: <code>Boolean</code></li><li>默认: <code>true</code></li></ul><h4 id="zoomOnWheel"><a href="#zoomOnWheel" class="headerlink" title="zoomOnWheel"></a>zoomOnWheel</h4><blockquote><p>是否开启通过鼠标滚轮缩放图片功能，默认开启，需要在<code>zoomable</code>属性设置为<code>true</code>情况下才可用</p></blockquote><ul><li>类型: <code>Boolean</code></li><li>默认: <code>true</code></li></ul><h4 id="zoomOnTouch"><a href="#zoomOnTouch" class="headerlink" title="zoomOnTouch"></a>zoomOnTouch</h4><blockquote><p>是否开启通过拖动触摸缩放图片功能，默认开启，需要在<code>zoomable</code>属性设置为<code>true</code>情况下才可用</p></blockquote><ul><li>类型: <code>Boolean</code></li><li>默认: <code>true</code></li></ul><h4 id="wheelZoomRatio"><a href="#wheelZoomRatio" class="headerlink" title="wheelZoomRatio"></a>wheelZoomRatio</h4><blockquote><p>定义使用鼠标滚轮缩放的时候缩放的比例值，默认是<code>0.1</code>，表示滚动滑轮一下缩小或放大图片的<code>10%</code></p></blockquote><ul><li>类型: <code>Number</code></li><li>默认: <code>0.1</code></li></ul><h4 id="cropBoxMovable"><a href="#cropBoxMovable" class="headerlink" title="cropBoxMovable"></a>cropBoxMovable</h4><blockquote><p>是否开启裁切框可拖动，默认开启表示可以移动裁切框</p></blockquote><ul><li>类型: <code>Boolean</code></li><li>默认: <code>true</code></li></ul><h4 id="cropBoxResizable"><a href="#cropBoxResizable" class="headerlink" title="cropBoxResizable"></a>cropBoxResizable</h4><blockquote><p>是否开启裁切框可调整大小，默认开启表示可以调整裁切框大小，如果设置为<code>false</code>将不显示可拖动缩放句柄</p></blockquote><ul><li>类型: <code>Boolean</code></li><li>默认: <code>true</code></li></ul><h4 id="toggleDragModeOnDblclick"><a href="#toggleDragModeOnDblclick" class="headerlink" title="toggleDragModeOnDblclick"></a>toggleDragModeOnDblclick</h4><blockquote><p>是否开启双击裁切框后可以从新创建裁切框功能，如果设置为<code>true</code>表示开启，可以双击裁切框后，在图片上拖动从新创建新的裁切框，再次双击关闭。</p></blockquote><ul><li>类型: <code>Boolean</code></li><li>默认: <code>true</code></li></ul><h4 id="minContainerWidth"><a href="#minContainerWidth" class="headerlink" title="minContainerWidth"></a>minContainerWidth</h4><blockquote><p>表示默认容器的最小宽度，默认最小宽度是200像素。</p></blockquote><ul><li>类型: <code>Number</code></li><li>默认: <code>200</code></li></ul><h4 id="minContainerWidth-1"><a href="#minContainerWidth-1" class="headerlink" title="minContainerWidth"></a>minContainerWidth</h4><blockquote><p>表示默认容器的最小高度，默认最小宽度是100像素。</p></blockquote><ul><li>类型: <code>Number</code></li><li>默认: <code>100</code></li></ul><h4 id="minCanvasWidth"><a href="#minCanvasWidth" class="headerlink" title="minCanvasWidth"></a>minCanvasWidth</h4><blockquote><p>表示默认画布（图片容器）的最小宽度，默认最小宽度是0像素。</p></blockquote><ul><li>类型: <code>Number</code></li><li>默认: <code>0</code></li></ul><h4 id="minCanvasHeight"><a href="#minCanvasHeight" class="headerlink" title="minCanvasHeight"></a>minCanvasHeight</h4><blockquote><p>表示默认画布（图片容器）的最小高度，默认最小高度是0像素。可以大于容器高度</p></blockquote><ul><li>类型: <code>Number</code></li><li>默认: <code>0</code></li></ul><h4 id="minCropBoxHeight"><a href="#minCropBoxHeight" class="headerlink" title="minCropBoxHeight"></a>minCropBoxHeight</h4><blockquote><p>表示可改变裁切框的最小高度，默认最小高度是0像素。当设置了<code>aspectRatio</code>属性，应该按照此属性的比例计算高度，高度可能会小于此值</p></blockquote><ul><li>类型: <code>Number</code></li><li>默认: <code>0</code></li></ul><h4 id="minCropBoxWidth"><a href="#minCropBoxWidth" class="headerlink" title="minCropBoxWidth"></a>minCropBoxWidth</h4><blockquote><p>表示默认裁切框的最小宽度，默认最小宽度是0像素。当设置了<code>aspectRatio</code>属性，应该按照此属性的比例计算宽度，宽度可能会小于此值</p></blockquote><ul><li>类型: <code>Number</code></li><li>默认: <code>0</code></li></ul><h4 id="ready"><a href="#ready" class="headerlink" title="ready"></a>ready</h4><blockquote><p>当实例化对象后触发的方法(只执行一次)</p></blockquote><ul><li>类型: <code>Function</code></li><li>默认: <code>null</code></li></ul><h4 id="cropstart"><a href="#cropstart" class="headerlink" title="cropstart"></a>cropstart</h4><blockquote><p>当裁切开始时触发的事件，包括开始创建裁切框，移动裁切框开始，移动图片开始等都会触发此方法，滚轮放大缩小图片不执行此方法</p></blockquote><ul><li>类型: <code>Function</code></li><li>默认: <code>null</code></li></ul><h4 id="cropmove"><a href="#cropmove" class="headerlink" title="cropmove"></a>cropmove</h4><blockquote><p>当裁切开始拖动时触发的事件，滚轮放大缩小图片不执行此方法</p></blockquote><ul><li>类型: <code>Function</code></li><li>默认: <code>null</code></li></ul><h4 id="cropend"><a href="#cropend" class="headerlink" title="cropend"></a>cropend</h4><blockquote><p>当裁切结束时触发的事件，就是鼠标抬起触发的事件</p></blockquote><ul><li>类型: <code>Function</code></li><li>默认: <code>null</code></li></ul><h4 id="crop"><a href="#crop" class="headerlink" title="crop"></a>crop</h4><blockquote><p>当裁切时触发的事件，包括改变裁切框大小，移动裁切框，移动图片，滚轮放大缩小图片等，都执行此方法，此方法中的的<code>event</code>参数里边包括裁切的数据</p></blockquote><ul><li>类型: <code>Function</code></li><li>默认: <code>null</code></li></ul><pre><code class="javascript">options:{  crop: function(event) {    console.log(&quot;crop-event&quot;, event);    console.log(event.detail.x);    console.log(event.detail.y);    console.log(event.detail.width);    console.log(event.detail.height);    console.log(event.detail.rotate);    console.log(event.detail.scaleX);    console.log(event.detail.scaleY);  }}</code></pre><h4 id="zoom"><a href="#zoom" class="headerlink" title="zoom"></a>zoom</h4><blockquote><p>当通过鼠标滚轮，或者触摸缩小放大图片的时候执行此方法</p></blockquote><ul><li>类型: <code>Function</code></li><li>默认: <code>null</code></li></ul><h3 id="方法-methods"><a href="#方法-methods" class="headerlink" title="方法(methods)"></a>方法(methods)</h3><blockquote><p>由于加载图像时存在异步过程，因此应在<code>ready</code>之后调用大多数方法，<code>setAspectRatio</code>，<code>replace</code>和“<code>destroy</code>除外。<br>如果方法没有被设置返回任何值，那么它会返回一个cropper的实例 因此多个方法可以使用链式写法</p></blockquote><h4 id="crop-1"><a href="#crop-1" class="headerlink" title="crop()"></a>crop()</h4><blockquote><p>手动显示裁切框，在实例化裁切器的时候我们可以先把<code>autoCrop</code>设置成<code>false</code>不显示裁切框，然后通过手动调<code>crop</code>方法来显示裁切框</p></blockquote><pre><code class="javascript">/* 两种方法手动显示裁切框 */var $image = $(&#39;#image&#39;);$image.cropper(options);// 方法一通过实例化裁切器的dom元素上一个cropper实例来调用var cropper = $image.data(&#39;cropper&#39;);cropper.crop(); //调用实例对象上的crop方法// 通过dom元素的jquery方法调用，crop是要执行的方法名，后边可以添加参数$image.cropper(&#39;crop&#39;);</code></pre><h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><blockquote><p>手动隐藏裁切框</p></blockquote><pre><code class="javascript">/* 两种方法手动移除裁切框 */var $image = $(&#39;#image&#39;);$image.cropper(options);// 方法一通过实例化裁切器的dom元素上一个cropper实例来调用var cropper = $image.data(&#39;cropper&#39;);cropper.clear(); //调用实例对象上的clear方法// 通过dom元素的jquery方法调用，clear是要执行的方法名，后边可以添加参数$image.cropper(&#39;clear&#39;);</code></pre><h4 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h4><blockquote><p>重置裁切框，从新初始化裁切框</p></blockquote><pre><code class="javascript">/* 两种方法手动初始化裁切框 */var $image = $(&#39;#image&#39;);$image.cropper(options);// 方法一通过实例化裁切器的dom元素上一个cropper实例来调用var cropper = $image.data(&#39;cropper&#39;);cropper.reset(); //调用实例对象上的reset方法// 通过dom元素的jquery方法调用，reset是要执行的方法名，后边可以添加参数$image.cropper(&#39;reset&#39;);</code></pre><h4 id="replace-url-hasSameSize"><a href="#replace-url-hasSameSize" class="headerlink" title="replace(url[, hasSameSize])"></a>replace(url[, hasSameSize])</h4><blockquote><p>从新更换裁切器的图片，替换图像的src并重建裁切器</p></blockquote><ul><li><p><code>url</code>:</p><ul><li>类型：<code>String</code></li><li>新图片的地址路径</li></ul></li><li><p><code>hasSameSize</code>:</p><blockquote><p><code>false</code>：替换图片地址，并从新创建裁切器；<code>true</code>：不重新创建裁切器只更换图片地址；<br>如果新图像的大小与旧图像的大小相同，则设置为<code>true</code>将不会重建裁切器，而只会更新所有相关图像的URL。这可以用于应用过滤器。</p></blockquote><ul><li>类型：<code>Boolean</code></li><li>默认：<code>false</code></li></ul></li></ul><pre><code class="javascript">/* 两种方法手动初始化裁切框 */var $image = $(&#39;#image&#39;);$image.cropper(options);// 方法一通过实例化裁切器的dom元素上一个cropper实例来调用var cropper = $image.data(&#39;cropper&#39;);cropper.replace(&#39;800-7.jpg&#39;); //调用实例对象上的replace方法// 通过dom元素的jquery方法调用，replace是要执行的方法名，后边可以添加参数$image.cropper(&#39;replace&#39;, &#39;800-7.jpg&#39;, true);</code></pre><h4 id="disable"><a href="#disable" class="headerlink" title="disable()"></a>disable()</h4><blockquote><p>锁定裁切器使裁切器不可用，包括裁切器的各种方法都不能用，<code>destroy()</code>方法除外。调用方式和上边方法调用方式相同。</p></blockquote><h4 id="enable"><a href="#enable" class="headerlink" title="enable()"></a>enable()</h4><blockquote><p>解除锁定裁切器使裁切器从新可用，包括裁切器的各种方法都恢复可用。</p></blockquote><h4 id="destroy"><a href="#destroy" class="headerlink" title="destroy()"></a>destroy()</h4><blockquote><p>销毁当前的裁切器，并移除所有裁切器的dom元素，只留下原始图片。销毁后所有方法不可再用。</p></blockquote><h4 id="move-offsetX-offsetY"><a href="#move-offsetX-offsetY" class="headerlink" title="move(offsetX[, offsetY])"></a>move(offsetX[, offsetY])</h4><blockquote><p>移动图片方法，调用此方法来左右，或者上下移动指定像素位。调用这个方法移动完毕后，会调用<code>crop</code>参数的方法</p></blockquote><ul><li><p><code>offsetX</code></p><blockquote><p>水平方左右移动指定大小，单位像素（px）。取正直图片向右移动，取负值图片向左移动</p></blockquote><ul><li>类型：<code>Number</code></li></ul></li><li><p><code>offsetY</code></p><blockquote><p>垂直方上下移动指定大小，单位像素（px）。取正直图片向下移动，取负值图片向上移动</p></blockquote><ul><li>类型：<code>Number</code></li></ul></li></ul><h4 id="moveTo-x-y"><a href="#moveTo-x-y" class="headerlink" title="moveTo(x[, y])"></a>moveTo(x[, y])</h4><blockquote><p>移动图片到指定位置，调用此方法来左右，或者上下移动图片到指定位置，调用这个方法移动完毕后，会调用<code>crop</code>参数的方法</p></blockquote><ul><li><p><code>x</code></p><blockquote><p>水平方左右移动图片到指定位置，单位像素（px）。取正直图片向右移动，取负值图片向左移动</p></blockquote><ul><li>类型：<code>Number</code></li></ul></li><li><p><code>y</code></p><blockquote><p>垂直方上下移动图片到指定位置，单位像素（px）。取正直图片向下移动，取负值图片向上移动</p></blockquote><ul><li>类型：<code>Number</code></li></ul></li></ul><h4 id="zoom-ratio"><a href="#zoom-ratio" class="headerlink" title="zoom(ratio)"></a>zoom(ratio)</h4><blockquote><p>图片缩放比。调用这个方法缩放完毕后，会调用<code>crop</code>参数的方法，和<code>zoom</code>参数的方法</p></blockquote><ul><li><p><code>ratio</code></p><blockquote><p>图片的缩放比例，-1 - 0 - 1之间的数字取正直图片放大，取负值图片缩小</p></blockquote><ul><li>类型：<code>Number</code></li></ul></li></ul><h4 id="zoomTo-ratio-pivot"><a href="#zoomTo-ratio-pivot" class="headerlink" title="zoomTo(ratio,[, pivot])"></a>zoomTo(ratio,[, pivot])</h4><blockquote><p>图片缩放到指定比例大小。调用这个方法移动完毕后，会调用<code>crop</code>参数的方法，和<code>zoom</code>参数的方法</p></blockquote><ul><li><p><code>ratio</code></p><blockquote><p>图片的缩放比例，大于0的数字，表示缩放的倍数</p></blockquote><ul><li>类型：<code>Number</code></li></ul></li><li><p><code>pivot</code></p><blockquote><p>图片缩放的时候设置的缩放中心点，基于裁切容器的左上角</p></blockquote><ul><li>类型：<code>Object</code></li><li>格式：<code>{ x: Number, y: Number }</code></li></ul></li></ul><pre><code class="javascript">/* 两种方法手动初始化裁切框 */const $image = $(&#39;#image&#39;);$image.cropper(options);// 方法一通过实例化裁切器的dom元素上一个cropper实例来调用const cropper = $image.data(&#39;cropper&#39;);const containerData = cropper.getContainerData();//获取裁切器的宽高等数据cropper.zoomTo(.5, {  // 已裁切器宽度10%的位置作为x轴坐标  // 已裁切器高度10%的位置作为y轴坐标  // 已得到的x，y作为缩放的中心点开始缩放          x: containerData.width / 10,          y: containerData.height / 10,        });// 通过dom元素的jquery方法调用，zoomTo是要执行的方法名，后边可以添加参数$image.cropper(&#39;zoomTo&#39;, .5, {          x: containerData.width / 10,          y: containerData.height / 10,        });</code></pre><h4 id="rotate-degree"><a href="#rotate-degree" class="headerlink" title="rotate(degree)"></a>rotate(degree)</h4><blockquote><p>图片旋转的方法。调用这个方法旋转完毕后，会调用<code>crop</code>参数的方法，此方法用到了css3中的2D旋转属性<code>transform</code>，需要浏览器支持css3</p></blockquote><ul><li><p><code>degree</code></p><blockquote><p>图片的旋转角度，取正直图片顺时针旋转，取负值图片逆时针旋转</p></blockquote><ul><li>类型：<code>Number</code></li></ul></li></ul><h4 id="rotateTo-degree"><a href="#rotateTo-degree" class="headerlink" title="rotateTo(degree)"></a>rotateTo(degree)</h4><blockquote><p>图片旋转到指定角度方法。调用这个方法旋转完毕后，会调用<code>crop</code>参数的方法，此方法用到了css3中的2D旋转属性<code>transform</code>，需要浏览器支持css3</p></blockquote><ul><li><p><code>degree</code></p><blockquote><p>图片的旋转角度，取正直图片顺时针旋转，取负值图片逆时针旋转</p></blockquote><ul><li>类型：<code>Number</code></li></ul></li></ul><h4 id="scale-scaleX-scaleY"><a href="#scale-scaleX-scaleY" class="headerlink" title="scale(scaleX, [scaleY])"></a>scale(scaleX, [scaleY])</h4><blockquote><p>翻转图片的方法。调用这个方法旋转完毕后，会调用<code>crop</code>参数的方法，此方法需要把参数中的<code>scalable</code>值设置为真，此方法用到了css3中的2D旋转属性<code>transform</code>，需要浏览器支持css3</p></blockquote><ul><li><p><code>scaleX</code></p><blockquote><p>水平翻转图片，-1表示水平翻转，1不做任何处理，</p></blockquote><ul><li>类型：<code>Number</code></li></ul></li><li><p><code>scaleY</code></p><blockquote><p>垂直翻转图片，-1表示垂直翻转，1不做任何处理</p></blockquote><ul><li>类型：<code>Number</code></li></ul></li></ul><h4 id="scaleX-scaleX"><a href="#scaleX-scaleX" class="headerlink" title="scaleX(scaleX)"></a>scaleX(scaleX)</h4><blockquote><p>水平翻转图片，-1表示水平翻转，1不做任何处理，</p></blockquote><ul><li>类型：<code>Number</code></li><li>默认：<code>1</code></li></ul><h4 id="scaleY-scaleY"><a href="#scaleY-scaleY" class="headerlink" title="scaleY(scaleY)"></a>scaleY(scaleY)</h4><blockquote><p>垂直翻转图片，-1表示垂直翻转，1不做任何处理，</p></blockquote><ul><li>类型：<code>Number</code></li><li>默认：<code>1</code></li></ul><h4 id="getData-rounded"><a href="#getData-rounded" class="headerlink" title="getData([rounded])"></a>getData([rounded])</h4><blockquote><p>获取最终裁切图片的信息</p></blockquote><ul><li><p>参数<code>rounded</code></p><blockquote><p>获取的值是否进行四舍五入, 取<code>true</code>表示进行</p></blockquote><ul><li>类型：<code>Boolean</code></li><li>默认：<code>false</code></li></ul></li><li><p>返回值</p><blockquote><p>输出最终裁切区域的位置和尺寸数据（基于原始图像的自然尺寸）。</p></blockquote><ul><li>类型：<code>Object</code></li><li>特征：<ul><li><code>x</code>：裁切区域的左偏移值</li><li><code>y</code>：裁切区域的上偏移值</li><li><code>width</code>：裁切区域的宽度</li><li><code>height</code>：裁切区域的高度</li><li><code>rotate</code>：图像的旋转角度</li><li><code>scaleX</code>：应用于图像横坐标的比例因子，图片左右翻转量</li><li><code>scaleY</code>：应用于图像纵坐标的比例因子，图片上下翻转量</li></ul></li></ul></li></ul><p><img src="/2020/03/26/jQuery/plugins/cropper/getData.jpg" alt="image"></p><pre><code class="javascript">/* 两种方法手动初始化裁切框 */var $image = $(&#39;#image&#39;);$image.cropper(options);// 方法一通过实例化裁切器的dom元素上一个cropper实例来调用var cropper = $image.data(&#39;cropper&#39;);const getData = cropper.getData(); //调用实例对象上的getData方法// 通过dom元素的jquery方法调用，getData是要执行的方法名，后边可以添加参数const getData = $image.cropper(&#39;getData&#39;, true);</code></pre><p>设置参数的返回值：</p><table><thead><tr><th>true</th><th>false</th></tr></thead><tbody><tr><td><img src="/2020/03/26/jQuery/plugins/cropper/getData_true.jpg" alt="image"></td><td><img src="/2020/03/26/jQuery/plugins/cropper/getData_false.jpg" alt="image"></td></tr></tbody></table><h4 id="setData-data"><a href="#setData-data" class="headerlink" title="setData(data)"></a>setData(data)</h4><blockquote><p>设置裁切框的数据，然后根据传过去的数据从新定位裁切框的位置大小，调用这个方法设置完毕后会同时执行<code>crop</code>方法两遍</p></blockquote><ul><li><p>参数：</p><blockquote><p>格式和<code>getData</code>方法返回的数据格式一样，可以传递一到多个值可选的值</p></blockquote><ul><li>类型：<code>Object</code></li></ul></li></ul><pre><code class="javascript">/* 两种方法手动初始化裁切框 */var $image = $(&#39;#image&#39;);$image.cropper(options);// 方法一通过实例化裁切器的dom元素上一个cropper实例来调用var cropper = $image.data(&#39;cropper&#39;);var setData1 = {x: 213.5, y: 215.3,width: 370,height: 370,rotate: 0,scaleX: 1,scaleY: 1};var setData2 = {x: 213.5};var setData3 = {x: 213.5,width: 370,height: 370};cropper.setData(setData3); //调用实例对象上的setData方法// 通过dom元素的jquery方法调用，setData是要执行的方法名，后边可以添加参数$image.cropper(&#39;setData&#39;, setData1);</code></pre><h4 id="getContainerData"><a href="#getContainerData" class="headerlink" title="getContainerData()"></a>getContainerData()</h4><blockquote><p>获取裁切器容器的大小</p></blockquote><ul><li>返回值<ul><li>类型 <code>Object</code><ul><li><code>width</code>：裁切器的宽度，也就是设置的Dom容器的宽度</li><li><code>height</code>：裁切器的高度，也就是设置的Dom容器的高度</li></ul></li></ul></li></ul><pre><code class="javascript">//调用实例对象上的getContainerData方法var containerData = cropper.getContainerData();// 通过dom元素的jquery方法调用，getContainerData是要执行的方法名var containerData = $image.cropper(&#39;getContainerData&#39;);console.log(containerData);</code></pre><p><img src="/2020/03/26/jQuery/plugins/cropper/getContainerData.jpg" alt="image"></p><h4 id="getImageData"><a href="#getImageData" class="headerlink" title="getImageData()"></a>getImageData()</h4><blockquote><p>获取图像的相关信息，包括大小，位置，缩放大小等和其他相关数据。</p></blockquote><ul><li>返回值<ul><li>类型 <code>Object</code><ul><li><code>left</code>：图像的左偏移量</li><li><code>top</code>：图像的上偏移量</li><li><code>width</code>：图像当前的宽度</li><li><code>height</code>：图像当前的高度</li><li><code>naturalWidth</code>：图片的原始宽度</li><li><code>naturalHeight</code>：图片的原始高度</li><li><code>aspectRatio</code>：图像的高宽比</li><li><code>rotate</code>：旋转图像的旋转角度</li><li><code>scaleX</code>：图片X轴的翻转量</li><li><code>scaleY</code>：图片Y轴的翻转量</li></ul></li></ul></li></ul><pre><code class="javascript">//调用实例对象上的getImageData方法var getImageData = cropper.getImageData();// 通过dom元素的jquery方法调用，getImageData是要执行的方法名var getImageData = $image.cropper(&#39;getImageData&#39;);console.log(getImageData);</code></pre><p><img src="/2020/03/26/jQuery/plugins/cropper/getImageData.jpg" alt="image"></p><h4 id="getCanvasData"><a href="#getCanvasData" class="headerlink" title="getCanvasData()"></a>getCanvasData()</h4><blockquote><p>获取图像的相关信息，包括大小，位置，缩放大小等和其他相关数据。</p></blockquote><ul><li>返回值<ul><li>类型 <code>Object</code><ul><li><code>left</code>：画布的左偏移量</li><li><code>top</code>：画布的上偏移</li><li><code>width</code>：画布的宽度</li><li><code>height</code>：画布的高度</li><li><code>naturalWidth</code>：画布的自然宽度（只读）</li><li><code>naturalHeight</code>：画布的自然高度（只读）</li></ul></li></ul></li></ul><pre><code class="javascript">// 获取画布信息var getCanvasData = cropper.getCanvasData();// var getCanvasData = $image.cropper(&#39;getCanvasData&#39;);console.log(getCanvasData);</code></pre><p><img src="/2020/03/26/jQuery/plugins/cropper/getCanvasData.jpg" alt="image"></p><h4 id="setCanvasData-data"><a href="#setCanvasData-data" class="headerlink" title="setCanvasData(data)"></a>setCanvasData(data)</h4><blockquote><p>使用新数据更改画布（图像包装器）的位置和大小，调用这个方法设置完毕后会同时执行<code>crop</code>方法两遍</p></blockquote><ul><li><p>参数：</p><blockquote><p>格式和<code>getCanvasData</code>方法返回的数据格式一样，可以传递一到多个值可选的值，更改是按照<code>viewMode</code>的参数值进行放大和缩小</p></blockquote><ul><li>类型：<code>Object</code></li></ul></li></ul><pre><code class="javascript">/* 两种方法手动初始化裁切框 */var $image = $(&#39;#image&#39;);$image.cropper(options);// 方法一通过实例化裁切器的dom元素上一个cropper实例来调用var cropper = $image.data(&#39;cropper&#39;);var setData1 = {left: 213.5, top: 215.3,width: 370,height: 370,naturalWidth: 0,naturalHeight: 1};var setData2 = {left: 213.5};var setData3 = {top: 213.5,width: 370,height: 370};cropper.setCanvasData(setData3); //调用实例对象上的setCanvasData方法// 通过dom元素的jquery方法调用，setCanvasData是要执行的方法名，后边可以添加参数$image.cropper(&#39;setCanvasData&#39;, setData1);</code></pre><h4 id="getCropBoxData"><a href="#getCropBoxData" class="headerlink" title="getCropBoxData()"></a>getCropBoxData()</h4><blockquote><p>获取裁切框的相关信息，包括大小，位置，等相关数据。</p></blockquote><ul><li>返回值<ul><li>类型 <code>Object</code><ul><li><code>left</code>：裁切框左偏移像素</li><li><code>top</code>：裁切框的上偏移像素</li><li><code>width</code>：裁切框的宽度</li><li><code>height</code>：裁切框的高度</li></ul></li></ul></li></ul><pre><code class="javascript">// 获取画布信息var getCropBoxData = cropper.getCropBoxData();// var getCropBoxData = $image.cropper(&#39;getCropBoxData&#39;);console.log(getCropBoxData);</code></pre><p><img src="/2020/03/26/jQuery/plugins/cropper/getCropBoxData.jpg" alt="image"></p><h4 id="setCropBoxData-data"><a href="#setCropBoxData-data" class="headerlink" title="setCropBoxData(data)"></a>setCropBoxData(data)</h4><blockquote><p>设置裁切框的位置和大小，调用这个方法设置完毕后会同时执行<code>crop</code>方法</p></blockquote><ul><li><p>参数：</p><blockquote><p>格式和<code>getCropBoxData</code>方法返回的数据格式一样，可以传递一到多个值可选的值，更改是按照<code>viewMode</code>的参数值进行放大和缩小</p></blockquote><ul><li>类型：<code>Object</code></li></ul></li></ul><pre><code class="javascript">// 设置裁切框大小和位置setCropBoxData = {left: 10, top: 10, width: 100, height:20}// cropper.setCropBoxData(setCropBoxData)$image.cropper(&#39;setCropBoxData&#39;, setCropBoxData);</code></pre><h4 id="getCroppedCanvas"><a href="#getCroppedCanvas" class="headerlink" title="getCroppedCanvas()"></a>getCroppedCanvas()</h4><blockquote><p>获取裁切框的相关信息，包括大小，位置，等相关数据。</p></blockquote><ul><li>返回值<ul><li>类型 <code>Object</code><ul><li><code>left</code>：裁切框左偏移像素</li><li><code>top</code>：裁切框的上偏移像素</li><li><code>width</code>：裁切框的宽度</li><li><code>height</code>：裁切框的高度</li></ul></li></ul></li></ul><pre><code class="javascript">// 获取画布信息var getCropBoxData = cropper.getCropBoxData();// var getCropBoxData = $image.cropper(&#39;getCropBoxData&#39;);console.log(getCropBoxData);</code></pre><p><img src="/2020/03/26/jQuery/plugins/cropper/getCropBoxData.jpg" alt="image"></p><h4 id="setAspectRatio-aspectRatio"><a href="#setAspectRatio-aspectRatio" class="headerlink" title="setAspectRatio(aspectRatio)"></a>setAspectRatio(aspectRatio)</h4><blockquote><p>设置裁切框的裁切比例，参数需要为正数，调用这个方法设置完毕后会同时执行<code>crop</code>方法</p></blockquote><ul><li>参数<ul><li>类型：<code>Number</code></li></ul></li></ul><h4 id="setDragMode-mode"><a href="#setDragMode-mode" class="headerlink" title="setDragMode([mode])"></a>setDragMode([mode])</h4><blockquote><p>设置裁切器的拖动模式，您可以通过双击裁切器来切换“裁切”和“移动”模式。</p></blockquote><ul><li>参数<ul><li>类型：<code>String</code></li><li>默认：<code>none</code></li><li>选项：<code>none</code>、<code>crop</code>、<code>move</code></li></ul></li></ul><h3 id="事件-Events"><a href="#事件-Events" class="headerlink" title="事件(Events)"></a>事件(Events)</h3><blockquote><p>可以通过给绑定了裁切器的Dom图片元素绑定事件，来执行一些方法，可以通过两种方式绑定，<br>1、通过jQuery的on绑定；<br>2、通过原生js的addEventListener方法绑定；</p></blockquote><h4 id="ready-1"><a href="#ready-1" class="headerlink" title="ready"></a>ready</h4><blockquote><p>当目标图像已加载且裁切器实例已准备好运行时，将触发此事件。</p></blockquote><ul><li>类型：<code>Event</code></li></ul><pre><code class="javascript">// 通过jquery绑定事件$image.on(&#39;ready&#39;, function (event) {  // 这里的事件是通过jquery处理的事件对象  console.log(event);});// 通过js原生绑定$image[0].addEventListener(&#39;ready&#39;, function (event) {  // 这里的事件是原生js事件对象  console.log(event);});</code></pre><h4 id="cropstart-1"><a href="#cropstart-1" class="headerlink" title="cropstart"></a>cropstart</h4><blockquote><p>当裁切开始，或裁切框开始更改的时候触发此事件</p></blockquote><p>执行方法后的<code>event</code>参数对象详细介绍</p><ul><li>event.detail.originalEvent 事件的详细信息<ul><li>类型：<code>Event</code></li><li>可能的事件类型：<code>mousedown</code>、<code>touchstart</code>、<code>pointerdown</code></li></ul></li><li>event.detail.action 事件动作的详细信息<ul><li>类型：<code>Sting</code></li><li>可能的值：<ul><li><code>crop</code>：创建一个新的裁切框</li><li><code>move</code>：移动画布（图像包装器）</li><li><code>zoom</code>：通过触摸放大/缩小画布（图像包装器）。</li><li><code>e</code>：调整裁切框东侧的大小</li><li><code>w</code>：调整裁切框西侧的大小</li><li><code>s</code>：调整裁切框南侧的大小</li><li><code>n</code>：调整裁切框北侧的大小</li><li><code>se</code>：调整裁切框东南侧的大小</li><li><code>sw</code>：调整裁切框西南侧的大小</li><li><code>ne</code>：调整裁切框东北的大小</li><li><code>nw</code>：调整裁切框西北侧的大小</li><li><code>all</code>：移动裁切框（所有方向）</li></ul></li></ul></li></ul><p>可以通过下列方式得到：</p><pre><code class="javascript">  // 通过js原生绑定  $image[0].addEventListener(&#39;cropstart&#39;, (event) =&gt; {    console.log(event.detail.originalEvent);    console.log(event.detail.action);  });  // 通过jquery绑定  $image.on(&#39;cropstart&#39;, (event) =&gt; {    console.log(event.detail.originalEvent);    console.log(event.detail.action);  });</code></pre><h4 id="cropmove-1"><a href="#cropmove-1" class="headerlink" title="cropmove"></a>cropmove</h4><blockquote><p>当移动或者更改裁切框时候触发此事件</p></blockquote><p>执行方法后的<code>event</code>参数对象详细介绍</p><ul><li>event.detail.originalEvent 事件的详细信息<ul><li>类型：<code>Event</code></li><li>可能的事件类型：<code>mousemove</code>、<code>touchmove</code>、<code>pointermove</code></li></ul></li><li>event.detail.action 事件的详细信息和<code>cropstart</code>的一样</li></ul><h4 id="cropend-1"><a href="#cropend-1" class="headerlink" title="cropend"></a>cropend</h4><blockquote><p>当停止移动或者停止更改裁切框时候触发此事件</p></blockquote><p>执行方法后的<code>event</code>参数对象详细介绍</p><ul><li>event.detail.originalEvent 事件的详细信息<ul><li>类型：<code>Event</code></li><li>可能的事件类型：<code>mouseend</code>、<code>touchend</code>、<code>pointerend</code></li></ul></li><li>event.detail.action 事件的详细信息和<code>cropstart</code>的一样</li></ul><h4 id="crop-2"><a href="#crop-2" class="headerlink" title="crop"></a>crop</h4><blockquote><p>当画布或裁切框发生变化时触发。</p></blockquote><p>执行方法后的<code>event</code>参数对象详细介绍</p><ul><li>event.detail 事件中的数据详细信息，和<code>getDate</code>方法得到的数据相同，，能够得到最终裁切区域的位置和尺寸数据（基于原始图像的原尺寸）。<ul><li>类型：<code>Object</code><ul><li><code>x</code>：裁切区域的左偏移值</li><li><code>y</code>：裁切区域的上偏移值</li><li><code>width</code>：裁切区域的宽度</li><li><code>height</code>：裁切区域的高度</li><li><code>rotate</code>：图像的旋转角度</li><li><code>scaleX</code>：应用于图像横坐标的比例因子，图片左右翻转量</li><li><code>scaleY</code>：应用于图像纵坐标的比例因子，图片上下翻转量</li></ul></li></ul></li></ul><h4 id="zoom-1"><a href="#zoom-1" class="headerlink" title="zoom"></a>zoom</h4><blockquote><p>裁切器开始放大或缩小其画布（图像包装器）时，将触发此事件。</p></blockquote><p>执行方法后的<code>event</code>参数对象详细介绍</p><ul><li><p>event.detail.originalEvent：</p><ul><li>类型： <code>Event</code></li><li>事件类型：<code>wheel</code>，<code>touchmove</code>。</li></ul></li><li><p>event.detail.oldRatio：</p></li></ul><blockquote><p>画布缩放前的旧（当前）比率</p><ul><li>类型： <code>Number</code></li></ul></blockquote><ul><li>event.detail.ratio：</li></ul><blockquote><p>画布缩放后的新（下一个）比例（canvasData.width / canvasData.naturalWidth）</p><ul><li>类型： <code>Number</code></li></ul></blockquote><p><img src="/2020/03/26/jQuery/plugins/cropper/zoom.jpg" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> plugins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> jQuery插件 </tag>
            
            <tag> 图片处理 </tag>
            
            <tag> 图片裁切 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css3中的filter滤镜使用</title>
      <link href="/2020/02/23/CSS3/filter/"/>
      <url>/2020/02/23/CSS3/filter/</url>
      
        <content type="html"><![CDATA[<h1 id="css3中的filter滤镜使用"><a href="#css3中的filter滤镜使用" class="headerlink" title="css3中的filter滤镜使用"></a>css3中的filter滤镜使用</h1><blockquote><p><code>filter</code> 滤镜，借鉴了Photoshop的滤镜效果，在ps中主要用来设置图层图片的模糊，颜色的高亮，对比度等效果，在css中滤镜通常用于调整图像，背景和边框的渲染和效果。</p></blockquote><table><thead><tr><th>函数名</th><th>取值</th><th>作用</th></tr></thead><tbody><tr><td>grayscale</td><td>值为0-1之间的小数, 或0%-100%百分数</td><td>灰度</td></tr><tr><td>sepia</td><td>值为0-1之间的小数, 或0%-100%百分数</td><td>褐色</td></tr><tr><td>saturate</td><td>值为num</td><td>饱和度</td></tr><tr><td>hue-rotate</td><td>值为angle</td><td>色相旋转</td></tr><tr><td>invert</td><td>反色</td><td>值为0-1之间的小数</td></tr><tr><td>opacity</td><td>值为0-1之间的小数</td><td>透明度</td></tr><tr><td>brightness</td><td>值为0-1之间的小数</td><td>亮度</td></tr><tr><td>contrast</td><td>值为num</td><td>对比度</td></tr><tr><td>blur</td><td>值为length</td><td>模糊</td></tr><tr><td>drop-shadow</td><td>和投影取值相同</td><td>阴影</td></tr></tbody></table><a id="more"></a><p><strong>兼容性：</strong></p><p><img src="/2020/02/23/CSS3/filter/filter.png" alt="image"><br><a href="https://caniuse.com/#search=filter" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p><h2 id="grayscale-灰度模式"><a href="#grayscale-灰度模式" class="headerlink" title="grayscale 灰度模式"></a>grayscale 灰度模式</h2><blockquote><p>用来设置图像或者元素的灰度模式，也就是去掉所有颜色以灰色显示元素</p></blockquote><p><strong>基本语法：</strong> <code>filter:grayscale(val)</code></p><p><code>val</code> ：值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0，同时也可以去0-1之间小数；</p><pre><code class="css">/* 100%灰度 */filter:grayscale(1);/* 50%灰度 */filter:grayscale(0.5);/* 0%灰度 */filter:grayscale(0);</code></pre><p><strong>案例:</strong> <a href="https://codepen.io/qwguo88/pen/MWYQyqK" rel="external nofollow noopener noreferrer" target="_blank">Demo</a><br><strong>颜色灰度：</strong></p><iframe height="500" style="width: 100%;" scrolling="no" title="filter-color-grayscale" src="https://codepen.io/qwguo88/embed/MWYQyqK?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/MWYQyqK" rel="external nofollow noopener noreferrer" target="_blank">filter-color-grayscale</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><br><strong>图片灰度：</strong><br><iframe height="500" style="width: 100%;" scrolling="no" title="filter-img-grayscale" src="https://codepen.io/qwguo88/embed/yLNVdBp?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/yLNVdBp" rel="external nofollow noopener noreferrer" target="_blank">filter-img-grayscale</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="sepia-褐色"><a href="#sepia-褐色" class="headerlink" title="sepia 褐色"></a>sepia 褐色</h2><blockquote><p>将图片或者元素以褐色的形式显示，也就是复古效果。</p></blockquote><p><strong>基本语法：</strong> <code>filter:sepia(val)</code></p><p><code>val</code> ：值定义转换的比例。值为100%则完全是深褐色的，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0，同时也可以去0-1之间小数；</p><pre><code class="css">/* 0%深褐色 */filter:sepia(0);/* 10%深褐色 */filter:sepia(10%);/* 100%深褐色 */filter:sepia(100%);</code></pre><p><strong>案例：</strong> <a href="https://codepen.io/qwguo88/pen/Jjdbzyg" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="filter-sepia" src="https://codepen.io/qwguo88/embed/Jjdbzyg?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/Jjdbzyg" rel="external nofollow noopener noreferrer" target="_blank">filter-sepia</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="saturate-饱和度"><a href="#saturate-饱和度" class="headerlink" title="saturate 饱和度"></a>saturate 饱和度</h2><blockquote><p>用于设置图像的饱和度。</p></blockquote><p><strong>基本语法：</strong> <code>filter: saturate(val)</code></p><p><code>val</code> ：取值为0%则是完全不饱和，值为100%则图像无变化。其他值，则是效果的线性乘子。超过100%的值是允许的，则有更高的饱和度。 若值未设置，值默认是1，同时也可以去0-1之间小数。</p><pre><code class="css">/* 0%深褐色 */filter:saturate(0);/* 10%深褐色 */filter:saturate(10%);/* 100%深褐色 */filter:saturate(100%);</code></pre><p><strong>案例：</strong> <a href="https://codepen.io/qwguo88/pen/qBdqvPW" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="filter-saturate" src="https://codepen.io/qwguo88/embed/qBdqvPW?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/qBdqvPW" rel="external nofollow noopener noreferrer" target="_blank">filter-saturate</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="hue-rotate-色相旋转"><a href="#hue-rotate-色相旋转" class="headerlink" title="hue-rotate 色相旋转"></a>hue-rotate 色相旋转</h2><blockquote><p>给图像应用色相旋转。</p></blockquote><p><strong>基本语法：</strong> <code>filter: hue-rotate(angle)</code></p><p><code>angle</code> ：用于设定图像被调整的色环角度值。值为0deg，则图像无变化。若值未设置，默认值是0deg。该值虽然没有最大值，超过360deg的值相当于又绕一圈。</p><pre><code class="css">/* 无变化 */filter: hue-rotate(0deg);/* 色相旋转30度 */filter: hue-rotate(30deg);/* 色相旋转360度 */filter: hue-rotate(360deg);</code></pre><p><strong>案例：</strong> <a href="https://codepen.io/qwguo88/pen/XWbNLmx" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="filter-hue-rotate" src="https://codepen.io/qwguo88/embed/XWbNLmx?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/XWbNLmx" rel="external nofollow noopener noreferrer" target="_blank">filter-hue-rotate</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="invert-反色"><a href="#invert-反色" class="headerlink" title="invert 反色"></a>invert 反色</h2><blockquote><p>给图片进行反转取色显示</p></blockquote><p><strong>基本语法：</strong> <code>filter: invert(val)</code></p><p><code>val</code> ：取值为100%表示完全反转。值为0%则图像无变化。值在0%和100%之间。 若值未设置，值默认是0。，同时也可以去0-1之间小数。</p><pre><code class="css">/* 无变化 */filter: invert(0);/* 取反30% */filter: invert(30%);/* or */filter: invert(.3);</code></pre><p><strong>案例：</strong> <a href="https://codepen.io/qwguo88/pen/PoqbMWe" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="filter-invert" src="https://codepen.io/qwguo88/embed/PoqbMWe?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/PoqbMWe" rel="external nofollow noopener noreferrer" target="_blank">filter-invert</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="opacity-透明度"><a href="#opacity-透明度" class="headerlink" title="opacity 透明度"></a>opacity 透明度</h2><blockquote><p>给图像或者元素设置透明度，该函数与已有的opacity属性很相似，不同之处在于通过filter，一些浏览器为了提升性能会提供硬件加速。</p></blockquote><p><strong>基本语法：</strong> <code>filter: opacity(val)</code></p><p><code>val</code> ： 取值为0%则是完全透明，值为100%则图像无变化。值在0%和100%之间。 若值未设置，值默认是1。</p><pre><code class="css">/* 无变化 */filter: opacity(0);/* 透明度30% */filter: opacity(30%);/* or */filter: opacity(.3);</code></pre><p><strong>案例：</strong> <a href="https://codepen.io/qwguo88/pen/MWwbNPa" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="filter-opacity" src="https://codepen.io/qwguo88/embed/MWwbNPa?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/MWwbNPa" rel="external nofollow noopener noreferrer" target="_blank">filter-opacity</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="brightness-亮度"><a href="#brightness-亮度" class="headerlink" title="brightness 亮度"></a>brightness 亮度</h2><blockquote><p>用于设置图像的亮度，给图片应用一种线性乘法，使其看起来更亮或更暗。</p></blockquote><p><strong>基本语法：</strong> <code>filter: brightness(val)</code></p><p><code>val</code> ： 取值如果是0%，图像会全黑。取值是100%，则图像无变化。其他的值对应线性乘数效果。值超过100%也是可以的，图像会比原来更亮。如果没有设定值，默认是1。</p><pre><code class="css">/* 无变化 */filter: brightness(0);/* 图像变暗70% */filter: brightness(30%);/* or */filter: brightness(.3);</code></pre><p><strong>案例：</strong> <a href="https://codepen.io/qwguo88/pen/xxGRveL" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="filter-brightness" src="https://codepen.io/qwguo88/embed/xxGRveL?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/xxGRveL" rel="external nofollow noopener noreferrer" target="_blank">filter-brightness</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="contrast-对比度"><a href="#contrast-对比度" class="headerlink" title="contrast 对比度"></a>contrast 对比度</h2><blockquote><p>用于设置图像的对比度，</p></blockquote><p><strong>基本语法：</strong> <code>filter: contrast(val)</code></p><p><code>val</code> ： 值是0%的话，图像会全灰。值是100%，图像不变。值可以超过100%，意味着会运用更低的对比。若没有设置值，默认是1。</p><pre><code class="css">/* 无变化 */filter: contrast(0);/* 图像对比度变暗70% */filter: contrast(30%);/* or */filter: contrast(.3);</code></pre><p><strong>案例：</strong> <a href="https://codepen.io/qwguo88/pen/OJVbKKG" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="filter-contrast" src="https://codepen.io/qwguo88/embed/OJVbKKG?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/OJVbKKG" rel="external nofollow noopener noreferrer" target="_blank">filter-contrast</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="blur-模糊度"><a href="#blur-模糊度" class="headerlink" title="blur 模糊度"></a>blur 模糊度</h2><blockquote><p>用于设置图像的高斯模糊度</p></blockquote><p><strong>基本语法：</strong> <code>filter: blur(radius)</code></p><p><code>radius</code> ：设定高斯函数的标准差，或者是屏幕上以多少像素融在一起，所以值越大越模糊；如果没有设定值，则默认是0；这个参数可设置css长度值（em、px、rem、pt）等，但不接受百分比值。</p><pre><code class="css">/* 无变化 */filter: blur(0);/* 设置图像高斯模糊2个像素融合 */filter: blur(2px);/* 设置图像高斯模糊5个像素融合 */filter: blur(5px);</code></pre><p><strong>案例：</strong> <a href="https://codepen.io/qwguo88/pen/OJVbKKG" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="filter-contrast" src="https://codepen.io/qwguo88/embed/OJVbKKG?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/OJVbKKG" rel="external nofollow noopener noreferrer" target="_blank">filter-contrast</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="drop-shadow-投影"><a href="#drop-shadow-投影" class="headerlink" title="drop-shadow 投影"></a>drop-shadow 投影</h2><blockquote><p>设置图像或元素的投影效果，他和box-shadow效果一样，但是区别在于他不能使用<code>inset</code>设置内阴影，也不能同时这只多个阴影。</p></blockquote><p><strong>基本语法：</strong> <code>filter: drop-shadow(offset-x offset-y blur-radius color);</code></p><p><code>offset-x</code>：设置投影的x轴的投影大小，取正直为投影像右偏移，取负值为投影像左偏移；<br><code>offset-y</code>：设置投影的Y轴的投影大小，取正直为投影像下偏移，取负值为投影像上偏移；<br><code>blur-radius</code>：表示投影的模糊半径值，值越大表示投影越模糊并且越大，取0表示投影不进行模糊处理，此属性不支持负数；<br><code>color</code>：表示投影的颜色，可以使用颜色关键字(red)，十六进制法(#fff)，rgb，rgba等写法；</p><pre><code class="css">/* 只设置offset-x */filter: drop-shadow(10px 0 0 red);/* 只设置offset-y */filter: drop-shadow(0 10px 0 #c00);/* 只设置blur-radius */filter: drop-shadow(0 0 10px rgb(255, 0, 0, .5))/* 同时设置 */filter: drop-shadow(10px 20px 20px rgba(0, 0, 0, .5))</code></pre><p><strong>案例</strong> <a href="https://codepen.io/qwguo88/pen/rNVdRJq" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="filter-drop-shadow" src="https://codepen.io/qwguo88/embed/rNVdRJq?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/rNVdRJq" rel="external nofollow noopener noreferrer" target="_blank">filter-drop-shadow</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
            <tag> CSS </tag>
            
            <tag> filter </tag>
            
            <tag> 滤镜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>codeText</title>
      <link href="/2020/02/23/codeText/"/>
      <url>/2020/02/23/codeText/</url>
      
        <content type="html"><![CDATA[<pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;style&gt;    b{      color:#c00;    }  &lt;/style&gt;  &lt;script&gt;    function(){      alert(123);    }  &lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;abc&quot;&gt;&lt;/div&gt;  &lt;p class=&quot;abc&quot; id=&quot;p&quot; data-a=&quot;数据&quot;&gt;p标签&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="css">sub,sup {  font-size: 75%;  line-height: 0;  position: relative;  vertical-align: baseline;}sub {  bottom: -0.25em;}sup {  top: -0.5em;}</code></pre><pre><code class="less">  @media screen and (device-aspect-ratio: 1280/720) { … }  @media screen and (device-aspect-ratio: 2560/1440) { … }  html:lang(fr-be)  tr:nth-child(2n+1) /* represents every odd row of an HTML table */  img:nth-of-type(2n+1) { float: right; }  img:nth-of-type(2n) { float: left; }  body &gt; h2:not(:first-of-type):not(:last-of-type)  html|*:not(:link):not(:visited)  *|*:not(:hover)  p::first-line { text-transform: uppercase }  @namespace foo url(http://www.example.com);  foo|h1 { color: blue }  /* first rule */  span[hello=&quot;Ocean&quot;][goodbye=&quot;Land&quot;]  E[foo]{    padding:65px;  }</code></pre><pre><code class="scss">/* Some example SCSS */@import &quot;compass/css3&quot;;$variable: #333;$blue: #3bbfce;$margin: 16px;.content-navigation {  #nested {    background-color: black;  }  border-color: $blue;  color:    darken($blue, 9%);}.border {  padding: $margin / 2;  margin: $margin / 2;  border-color: $blue;}@mixin table-base {  th {    text-align: center;    font-weight: bold;  }  td, th {padding: 2px}}table.hl {  margin: 2em 0;  td.ln {    text-align: right;  }}li {  font: {    family: serif;    weight: bold;    size: 1.2em;  }}@mixin left($dist) {  float: left;  margin-left: $dist;}#data {  @include left(10px);  @include table-base;}.source {  @include flow-into(target);  border: 10px solid green;  margin: 20px;  width: 200px; }.new-container {  @include flow-from(target);  border: 10px solid red;  margin: 20px;  width: 200px; }body {  margin: 0;  padding: 3em 6em;  font-family: tahoma, arial, sans-serif;  color: #000;}@mixin yellow() {  background: yellow;}.big {  font-size: 14px;}.nested {  @include border-radius(3px);  @extend .big;  p {    background: whitesmoke;    a {      color: red;    }  }}#navigation a {  font-weight: bold;  text-decoration: none !important;}h1 {  font-size: 2.5em;}h2 {  font-size: 1.7em;}h1:before, h2:before {  content: &quot;::&quot;;}code {  font-family: courier, monospace;  font-size: 80%;  color: #418A8A;}</code></pre><pre><code class="vue">  &lt;template&gt;    &lt;div&gt;    &lt;/div&gt;  &lt;/template&gt;  &lt;script&gt;    export default {    }  &lt;/script&gt;  &lt;style lang=&quot;scss&quot; scoped&gt;    b{      color:#c00;      a{        color:#0c0      }    }  &lt;/style&gt;</code></pre><pre><code class="xml">&lt;html style=&quot;color: green&quot;&gt;  &lt;!-- this is a comment --&gt;  &lt;head&gt;    &lt;title&gt;HTML Example&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    The indentation tries to be &lt;em&gt;somewhat &amp;quot;do what    I mean&amp;quot;&lt;/em&gt;... but might not match your style.  &lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="javascript">  setTimeout(()=&gt;{    console.log(123)  });  function(){    alert(123);  }  var abc;  abc === bcd;</code></pre><pre><code class="js">  setTimeout(()=&gt;{    console.log(123)  });  function(){    alert(123);  }    var abc;</code></pre><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;sass&quot;&gt;Im am a {{mustache-like}} template&lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;coffee&quot;&gt;  module.exports =    props: [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]&lt;/script&gt;&lt;style lang=&quot;sass&quot;&gt;.sass  font-size: 18px&lt;/style&gt;</code></pre><pre><code class="php">&lt;?php$a = array(&#39;a&#39; =&gt; 1, &#39;b&#39; =&gt; 2, 3 =&gt; &#39;c&#39;);echo &quot;$a[a] ${a[3] /* } comment */} {$a[b]} \$a[a]&quot;;function hello($who) {    return &quot;Hello $who!&quot;;}?&gt;</code></pre><pre><code class="json">a:{  a: 10,  b: 30}</code></pre><pre><code class="TypeScript">class Site {   name():void {      console.log(&quot;Runoob&quot;)   }}var obj = new Site();obj.name();</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>transition轻松实现元素过度效果</title>
      <link href="/2019/12/21/CSS3/transition/"/>
      <url>/2019/12/21/CSS3/transition/</url>
      
        <content type="html"><![CDATA[<h1 id="transition过度属性"><a href="#transition过度属性" class="headerlink" title="transition过度属性"></a>transition过度属性</h1><blockquote><p><code>transition</code>：用于设置DOM元素在不同状态之间切换的时候应用不同的过度效果，以前如果要想实现一个非生硬的状态切换需要写很多的js来实现，现在使用<code>transition</code>变可以轻松的实现。</p></blockquote><h3 id="transition-property"><a href="#transition-property" class="headerlink" title="transition-property"></a>transition-property</h3><blockquote><p><code>property</code>：表示属性的意思，这里用来设置元素要过度的css属性名。</p></blockquote><p><strong>基本语法：</strong><br><code>transition: none | all | property;</code></p><ul><li><code>none</code>：表示没有任何过度效果。</li><li><code>all</code>：初始值，表示所有的能过度属性都有过度效果。</li><li><code>property</code>：指定一个或多个属性名称执行过度效果，多个css属性名之间用逗号分隔开。<a id="more"></a></li></ul><p><strong>例如：</strong></p><pre><code class="css">/* 单个属性过渡 */transition-property: width;/* 多个属性过渡用逗号分隔 */transition-property: window, height, background-color, opacity;/* 全部属性过渡 */transition-property: all;</code></pre><p><strong>兼容性：</strong></p><p><img src="/2019/12/21/CSS3/transition/transition-property-caniuse.png" alt="image"></p><p><a href="https://caniuse.com/#search=transition-property" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p><p>查看案例<a href="https://codepen.io/qwguo88/pen/YzzBPYM" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="transition-property" src="https://codepen.io/qwguo88/embed/YzzBPYM?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/YzzBPYM" rel="external nofollow noopener noreferrer" target="_blank">transition-property</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p>能够支持过度的css属性<a href="http://leaverou.github.io/animatable/" rel="external nofollow noopener noreferrer" target="_blank">查看1</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_animated_properties" rel="external nofollow noopener noreferrer" target="_blank">查看2</a></p><h3 id="transition-duration"><a href="#transition-duration" class="headerlink" title="transition-duration"></a>transition-duration</h3><blockquote><p><code>transition-duration</code>：表示过渡动画在多长时间内执行完毕。值以秒（s）或毫秒（ms）为单位不接受负值。可以指定多个值，每个值之间用逗号分开并且分别应用到 <code>transition-property</code> 指定的对应属性上。</p></blockquote><p><strong>基本语法：</strong><br><code>transition-duration: time;</code></p><ul><li><code>time</code>：指定动画执行时长。</li></ul><p><strong>例如：</strong></p><pre><code class="css">transition-duration: 10s;/* 如果是小数点左边只有一个0的话，前边的 0可以省略。 */transition-duration: .5s, 10ms, .9ms, 0.5s, 10.05s;</code></pre><p><strong>兼容性：</strong></p><p><img src="/2019/12/21/CSS3/transition/transition-duration-caniuse.png" alt="image"></p><p><a href="https://caniuse.com/#search=transition-duration" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p><p>查看案例<a href="https://codepen.io/qwguo88/pen/LYYazMY" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="transition-duration" src="https://codepen.io/qwguo88/embed/LYYazMY?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/LYYazMY" rel="external nofollow noopener noreferrer" target="_blank">transition-duration</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h3 id="transition-timing-function"><a href="#transition-timing-function" class="headerlink" title="transition-timing-function"></a>transition-timing-function</h3><blockquote><p><code>transition-timing-function</code>：指定一个函数，定义属性值怎么变化。缓动函数 Timing functions 定义属性如何计算。多数 timing functions 由四点定义一个 bezier 曲线。也可以从 Easing Functions Cheat Sheet 选择缓动效果。</p></blockquote><p><strong>基本语法：</strong><br><code>transition-timing-function: ease | ease-in | ease-out | ease-in-out | linear | cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;) | step-start | set-end | steps(&lt;integer&gt;[, &lt;step-position&gt;]?) | inherit</code></p><ul><li><code>ease</code>：慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。</li><li><code>ease-in</code>：慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。</li><li><code>ease-out</code>：慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。</li><li><code>ease-in-out</code>：慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。</li><li><code>linear</code>：以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。</li><li><code>steps(4, end)</code>：四次运动到结束执行过度效果。</li><li><code>cubic-bezier(x1, y1, x2, y2)</code>：以贝塞尔函数算法执行过度效果。生成贝塞尔曲线网站：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Tools/Cubic_Bezier_Generator" rel="external nofollow noopener noreferrer" target="_blank">website1</a>、<a href="https://cubic-bezier.com/" rel="external nofollow noopener noreferrer" target="_blank">website2</a>、<a href="https://easings.net/" rel="external nofollow noopener noreferrer" target="_blank">website</a></li></ul><p><img src="/2019/12/21/CSS3/transition/transition-timing-function-caniuse.png" alt="image"></p><p><a href="https://caniuse.com/#search=transition-timing-function" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p><p>查看案例<a href="https://codepen.io/qwguo88/pen/zYYXypo" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="transition-timing-function" src="https://codepen.io/qwguo88/embed/zYYXypo?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/zYYXypo" rel="external nofollow noopener noreferrer" target="_blank">transition-timing-function</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h3 id="transition-delay"><a href="#transition-delay" class="headerlink" title="transition-delay"></a>transition-delay</h3><blockquote><p><code>transition-delay</code>：延迟指定时间后执行过度效果。值以秒（s）或毫秒（ms）为单位。取值为正时会延迟一段时间来响应过渡效果；取值为负时会导致过渡立即开始。可以指定多个延迟时间，每个延迟用逗号分开，分别作用于你所指定的相符合的css属性<code>transition-property</code>;</p></blockquote><p><strong>基本语法：</strong><br><code>transition: time | inherit | initial | unset</code></p><ul><li><code>time</code>：指定的时间，格式：10s | 10ms | 0.5s  (.5s) | -10ms | -5s (-.5s)</li><li><code>inherit</code>：</li></ul><p><img src="/2019/12/21/CSS3/transition/transition-delay-caniuse.png" alt="image"></p><p><a href="https://caniuse.com/#search=transition-delay" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p><p>查看案例<a href="https://codepen.io/qwguo88/pen/qBBGOBG" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="transition-delay" src="https://codepen.io/qwguo88/embed/qBBGOBG?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/qBBGOBG" rel="external nofollow noopener noreferrer" target="_blank">transition-delay</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><blockquote><p><code>transition</code>：它是<code>transition-property</code>、<code>transition-duration</code>、<code>transition-timin-function</code>、<code>transition-delay</code> 的缩写形式，能够更方面的设置过渡效果，一般在开发中使用这种方式写过渡效果。</p></blockquote><p><strong>基本语法：</strong><br><code>transition: property duration timing-function delay | none</code></p><ul><li><code>none</code>：没有过渡效果。</li></ul><p><strong>基本写法：</strong></p><pre><code class="css">/* 两个值，属性名，过渡持续时间 */transition: margin-right 4s;/* 三个值，属性名，过渡持续时间，延迟开始过渡时间 */transition: margin-right 4s 1s;/* 三个值，属性名，过渡持续时间，过渡动画效果 */transition: margin-right 4s ease-in-out;/* 四个值，属性名，过渡持续时间，过渡动画效果，延迟开始过渡时间 */transition: margin-right 4s ease-in-out 1s;/* 可以同时写多个过渡属性，每个过渡之间用逗号分开 */transition: margin-right 4s, color 1s;/* 也可以使用all表示全部属性 */transition: all 0.5s ease-out;/* 其他 */transition: inherit;transition: initial;transition: unset;</code></pre><p><img src="/2019/12/21/CSS3/transition/transition-caniuse.png" alt="image"></p><p><a href="https://caniuse.com/#search=transition" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
            <tag> transition </tag>
            
            <tag> 过渡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css3中控制js事件行为</title>
      <link href="/2019/12/17/CSS3/cssEvents/"/>
      <url>/2019/12/17/CSS3/cssEvents/</url>
      
        <content type="html"><![CDATA[<h1 id="pointer-events"><a href="#pointer-events" class="headerlink" title="pointer-events"></a>pointer-events</h1><blockquote><p>属性指定在什么情况下某个特定的图形元素可以成为鼠标事件的 <code>target</code>，这个属性主要应用在<code>SVG</code>元素上，这篇文章主要介绍的是应用在HTML的DOM元素上</p></blockquote><p><strong>语法：</strong><br><code>pointer-events: auto | none | inherit | initial | unset;</code><br><a id="more"></a></p><ul><li><code>auto</code>：自动表示使用DOM的默认行为。</li><li><code>none</code>：表示该元素不执行任何的js事件，包括其后代元素。但是，当其后代元素的此属性指定其他值时，鼠标事件可以指向后代元素，在这种情况下，鼠标事件将在捕获或冒泡阶段触发父元素的事件侦听器。</li><li><code>inherit</code>：表示继承父级的<code>pointer-events</code>的值。</li><li><code>initial</code>：初始化，和<code>auto</code>效果一样，表示执行元素的默认行为。</li><li><code>unset</code>：未定义，继承父级行为。</li></ul><p><strong>兼容性：</strong><br><img src="/2019/12/17/CSS3/cssEvents/pointer-events-caniuse.png" alt="image"><br><a href="https://caniuse.com/#search=pointer-events" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p><p>查看案例 <a href="https://codepen.io/qwguo88/pen/MWWZWBj" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="pointer-events" src="https://codepen.io/qwguo88/embed/MWWZWBj?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/MWWZWBj" rel="external nofollow noopener noreferrer" target="_blank">pointer-events</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h1 id="touch-action"><a href="#touch-action" class="headerlink" title="touch-action"></a>touch-action</h1><blockquote><p>touch-action是控制手势事件过滤的CSS属性，为开发人员提供了一种声明性机制，以有选择地禁用触摸滚动（在一个或两个轴上）或双击缩放，用于设置触摸屏用户如何操纵元素的区域</p></blockquote><p><strong>语法：</strong><br><code>touch-action: auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation;</code></p><ul><li><code>auto</code>：初始化值，表示根据浏览器决定当用户触控事件发生时执行默认行为。</li><li><code>none</code>：禁用touch事件，表示把元素上的触屏事件行为禁用，当用户在元素上触发触控行为时不进行任何操作。</li><li><code>pan-x</code>：表示只开启x轴的滑动行为，也就是左右滑动。</li><li><code>pan-left</code>：表示只开启元素向左滑动。</li></ul><p><strong>兼容性：</strong><br><img src="/2019/12/17/CSS3/cssEvents/touch-action-caniuse.png" alt="image"><br><a href="https://caniuse.com/#search=touch-action" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p><p>查看案例 <a href="https://codepen.io/qwguo88/pen/YzzdyMd" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="touch-action" src="https://codepen.io/qwguo88/embed/YzzdyMd?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/YzzdyMd" rel="external nofollow noopener noreferrer" target="_blank">touch-action</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
            <tag> events </tag>
            
            <tag> touch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex布局</title>
      <link href="/2019/12/16/CSS3/flex/"/>
      <url>/2019/12/16/CSS3/flex/</url>
      
        <content type="html"><![CDATA[<h1 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h1><blockquote><p> flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。我们可以把任何容器转换成(flex container)称为<strong>弹性容器</strong>，它的所有子元素就变为(flex item)称为<strong>弹性项目成员</strong></p></blockquote><p>我们可以通过给任何容器元素添加 <code>display: flex;</code> <em>块级弹性容器</em> 和 <code>display:inline-flex;</code><em>行内块级弹性容器</em>；</p><p><strong><em>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</em></strong></p><h3 id="弹性容器的属性："><a href="#弹性容器的属性：" class="headerlink" title="弹性容器的属性："></a>弹性容器的属性：</h3><h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><blockquote><p>用于设置容器中的子项目排列方向，定义主轴的方向（正反方向）</p></blockquote><a id="more"></a><p><strong>语法：</strong><br><code>flex-direction: row | row-reverse | column | column-reverse;</code></p><ul><li><code>row</code>：默认值，容器的主轴被定义为与文本方向相同，主轴起点和主轴终点与内容方向相同。一般：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：表现和row的方向相同，但是置换了主轴起点和主轴终点。一般：主轴为水平方向，起点改为在右端。</li><li><code>column</code>：主轴为垂直方向，起点从上端向下开始排列。</li><li><code>column-reverse</code>：主轴和column一样垂直方向，起点改为相反方向，从下到上排列。</li></ul><p><strong>兼容性：</strong><br><img src="/2019/12/16/CSS3/flex/flex-direction-caniuse.png" alt="image"><br><a href="https://caniuse.com/#search=flex-direction" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p><p>查看案例：<a href="https://codepen.io/qwguo88/full/abbqyVY" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/abbqyVY</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="flex-direction" src="https://codepen.io/qwguo88/embed/abbqyVY?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/abbqyVY" rel="external nofollow noopener noreferrer" target="_blank">flex-direction</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><blockquote><p>定义容器中的子项目如果在一条轴线上排不下时如何显示。默认情况下，项目都排在一条线（又称”轴线”）上。</p></blockquote><p><strong>语法：</strong><br><code>flex-wrap: nowrap | wrap | wrap-reverse</code></p><ul><li><code>nowrap</code>：默认值，不换行，容器中的子项目强制在一条轴上显示，容器内的子元素会溢出显示，或者压缩显示。</li><li><code>wrap</code>：强制换行，当子项目排列超出容器后会自动换到下一行（<em>默认</em>）或者下一列，取决于<code>flex-direction</code>的设置。</li><li><code>wrap-reverse</code>：和 wrap 的行为一样强制换行，但是排列会从下开始往上排列换行，或者从右开始向左排列换行。</li></ul><p><strong>兼容性：</strong><br><img src="/2019/12/16/CSS3/flex/flex-wrap-caniuse.png" alt="image"><br><a href="https://caniuse.com/#search=flex-wrap" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p><p>查看案例：<a href="https://codepen.io/qwguo88/full/dyydwLr" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/dyydwLr</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="flex-wrap" src="https://codepen.io/qwguo88/embed/dyydwLr?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/dyydwLr" rel="external nofollow noopener noreferrer" target="_blank">flex-wrap</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><blockquote><p>它是<code>flex-direction</code> 和 <code>flow-wrap</code> 的简写形式，字面上理解就是flex容器中字项目的流向。</p></blockquote><p><strong>语法：</strong><br><code>flex-flow: &lt;&#39;flex-direction&#39;&gt; || &lt;&#39;flex-wrap&#39;&gt;;</code></p><p><strong>兼容性：</strong><br><img src="/2019/12/16/CSS3/flex/flex-flow-caniuse.png" alt="image"><br><a href="https://caniuse.com/#search=flex-flow" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p><p>查看案：<a href="https://codepen.io/qwguo88/full/KKKQYBN" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/KKKQYBN</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="flex-flow" src="https://codepen.io/qwguo88/embed/KKKQYBN?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/KKKQYBN" rel="external nofollow noopener noreferrer" target="_blank">flex-flow</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><blockquote><p>定义容器中的子项目在主轴线上的对齐方式</p></blockquote><p><strong>语法：</strong><br><code>justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;</code></p><ul><li><code>flex-start</code>：默认值、弹性容器的子项目将以行或列的起始位置对齐；</li><li><code>flex-end</code>：弹性容器的子项目将以行或列的结束位置对齐；</li><li><code>center</code>：弹性容器的子项目将居中对齐；</li><li><code>space-between</code>：弹性容器的子项目将平均分布对齐，每个子项之间间距相同，首尾子项将贴近容器边缘；</li><li><code>space-around</code>：弹性容器的子项目将平均分布对齐，首尾子项将不贴近容器边缘，每个子项的左右或上下间距相同；</li><li><code>space-evenly</code>：弹性容器的子项目将平均分布对齐，首尾子项将不贴近容器边缘，首尾子项贴近容器的间距和子项之间的间距相同；</li></ul><p><strong>兼容性：</strong><br><img src="/2019/12/16/CSS3/flex/justify-content-caniuse.png" alt="image"><br><a href="https://caniuse.com/#feat=mdn-css_properties_justify-content_flex_context" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p><p>查看案：<a href="https://codepen.io/qwguo88/full/LYYQoop" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/LYYQoop</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="justify-content" src="https://codepen.io/qwguo88/embed/LYYQoop?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/LYYQoop" rel="external nofollow noopener noreferrer" target="_blank">justify-content</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><blockquote><p>设置弹性容器中的子项目在副轴（默认纵轴）方向上的对齐方式</p></blockquote><p><strong>语法：</strong><br><code>align-items: stretch | flex-start | flex-end | center | baseline;</code></p><ul><li><code>stretch</code>：默认值，弹性容器的子项目如果不设置高度或者高度是auto，那么子项目将占满整个容器的高度，强制铺满副轴</li><li><code>flex-start</code>：弹性容器的子项目以副轴的起始位置对齐</li><li><code>flex-end</code>：弹性容器的子项目以副轴的结束位置对齐</li><li><code>center</code>：弹性容器的子项目以副轴的中点对齐</li><li><code>baseline</code>：弹性容器的子项目以项目的第一行文字的基线对齐</li></ul><p><strong>兼容性：</strong><br><img src="/2019/12/16/CSS3/flex/flex-align-items-caniuse.png" alt="image"><br><a href="https://caniuse.com/#feat=mdn-css_properties_align-items_flex_context" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p><p>查看案：<a href="https://codepen.io/qwguo88/full/NWWMjPG" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/NWWMjPG</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="align-items" src="https://codepen.io/qwguo88/embed/NWWMjPG?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/NWWMjPG" rel="external nofollow noopener noreferrer" target="_blank">align-items</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><blockquote><p>定义了弹性容器中多根轴线的对齐方式。如果项目只有一根轴线或（设置了flex-wrap-nowrap属性的弹性容器）将不起作用，也可以理解为子项目整体的对齐方式，会把子项目划分成一个组。</p></blockquote><p><strong>语法：</strong><br><code>align-content: stretch | flex-start | flex-end | center | space-between | space-around;</code></p><ul><li><code>stretch</code>：默认值，弹性容器的子项目如果不设置高度或者高度是auto，那么子项目将拉伸平均占满整个容器的高度或宽度</li><li><code>flex-start</code>：弹性容器的子项目以主轴的起始位置对齐</li><li><code>flex-end</code>：弹性容器的子项目以主轴的结束位置对齐</li><li><code>center</code>：弹性容器的子项目以主轴的中点对齐</li><li><code>space-between</code>：弹性容器的子项目以容器的两端对齐</li><li><code>space-around</code>：弹性容器的子项目平均分配容器的空间子项目间上下（或左右）间距相同</li></ul><p><strong>兼容性：</strong><br><img src="/2019/12/16/CSS3/flex/flex-align-content-caniuse.png" alt="image"><br><a href="https://caniuse.com/#feat=mdn-css_properties_align-content_flex_context" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p><p>查看案：<a href="https://codepen.io/qwguo88/full/ExxLoGv" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/ExxLoGv</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="align-centent" src="https://codepen.io/qwguo88/embed/ExxLoGv?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/ExxLoGv" rel="external nofollow noopener noreferrer" target="_blank">align-centent</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h3 id="弹性容器中的子项目的属性："><a href="#弹性容器中的子项目的属性：" class="headerlink" title="弹性容器中的子项目的属性："></a>弹性容器中的子项目的属性：</h3><h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><blockquote><p>设置弹性容器的子项是否拉伸填充容器的剩余空间</p></blockquote><p><strong>语法：</strong><br><code>flex-grow: number | 0</code></p><ul><li><code>0</code>：初始化值，表示不进行拉伸处理。</li><li><code>number</code>：只能取正整数。当容器中的子项目填充不满容器的时候，每个子项目将按照自身设置的<code>flew-grow:number</code>值来放大填充满剩余的空间。</li></ul><p>假设容器的宽度为400px, 子项1的占用的基础空间(flex-basis)为50px，子项2占用的基础空间是70px，子项3占用基础空间是100px，剩余空间为 400-50-70-100 = 180px。 其中子项1的<code>flex-grow: 0</code>(未设置默认为0)， 子项2的<code>flex-grow: 2</code>，子项3的<code>flex-grow: 1</code>，剩余空间分成3份，子项2占2份(120px)，子项3占1份(60px)。所以 子项1真实的占用空间为: 50+0 = 50px， 子项2真实的占用空间为: 70+120 = 190px， 子项3真实的占用空间为: 100+60 = 160px。</p><p><strong>兼容性：</strong><br><img src="/2019/12/16/CSS3/flex/flex-grow-caniuse.png" alt="image"><br><a href="https://caniuse.com/#search=flex-grow" rel="external nofollow noopener noreferrer" target="_blank">查看兼容详情</a></p><p>查看案：<a href="https://codepen.io/qwguo88/full/xxxjJZo" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/xxxjJZo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="flex-grow" src="https://codepen.io/qwguo88/embed/xxxjJZo?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/xxxjJZo" rel="external nofollow noopener noreferrer" target="_blank">flex-grow</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><blockquote><p>设置弹性容器的子项目在所有子项宽度之和大于容器总宽度是是否收缩。</p></blockquote><p><strong>语法：</strong><br><code>flew-shrink: number | 1</code></p><ul><li><code>1</code>：初始化值，表示每个子项目都进行缩放。</li><li><code>number</code>： 取值<code>0</code>表示不进行缩放，取值其他正整数表示进行缩放的系数。具体计算规则是：</li></ul><pre><code class="html">&lt;div class=&quot;box&quot;&gt;  &lt;div class=&quot;sub-1&quot;&gt;11111&lt;/div&gt;  &lt;div class=&quot;sub-2&quot;&gt;2&lt;/div&gt;  &lt;div class=&quot;sub-3&quot;&gt;3&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="less">.box{  display: flex;  width: 500px;  height: 200px;  .sub-1{    width: 100px;    flex-shrink: 1;  }  .sub-2{    width: 200px;    flex-shrink: 2;  }  .sub-3{    width: 300px;    flex-shrink: 3;  }}</code></pre><blockquote><p>先计算总权重TW = 100px <em> 1 (flex-shrink) + 200px </em> 2 (flex-shrink) + 300px * 3 (flex-shrink) = 1400px 也就是每个div的宽度乘以flex-shrink系数的总和。</p></blockquote><blockquote><p>每个div收缩的空间为：div的宽度 - div的宽度 <em> flex-shrink系数 / 总权重TW </em> 需要收缩的总宽度（在我们的例子中是600px - 500px = 100px）</p></blockquote><p>sub-1的宽度 =  100 - 100 <em> 1 / 1400 </em> 100 = 92.85714285714286 ≈ 92.86<br>sub-2的宽度 =  200 - 200 <em> 2 / 1400 </em> 100 = 171.42857142857144 ≈ 171.42<br>sub-3的宽度 =  300 - 300 <em> 3 / 1400 </em> 100 = 235.71428571428572 ≈ 235.71</p><p><strong>兼容性：</strong><br><img src="/2019/12/16/CSS3/flex/flex-shrink-caniuse.png" alt="image"><br><a href="https://caniuse.com/#search=flex-shrink" rel="external nofollow noopener noreferrer" target="_blank">查看兼容详情</a></p><p>查看案：<a href="https://codepen.io/qwguo88/full/vYYrEmp" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/vYYrEmp</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="flex-shrink" src="https://codepen.io/qwguo88/embed/vYYrEmp?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/vYYrEmp" rel="external nofollow noopener noreferrer" target="_blank">flex-shrink</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><blockquote><p>定义弹性容器的子项目在主轴方向上占容器的空间大小。<em>它要比<code>width</code>或者<code>height</code>权重高</em></p></blockquote><p><strong>语法：</strong><br><code>flex-basis: &lt;length&gt; | auto;</code></p><ul><li><code>length</code>：用于设置元素的宽度或者高度。</li><li><code>auto</code>：默认值，表示元素按照内容来分配宽度或高度。</li></ul><p><strong>兼容性：</strong><br><img src="/2019/12/16/CSS3/flex/flex-basis-caniuse.png" alt="image"><br><a href="https://caniuse.com/#search=flex-basis" rel="external nofollow noopener noreferrer" target="_blank">查看兼容详情</a></p><p>查看案：<a href="https://codepen.io/qwguo88/full/NWWzemV" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/NWWzemV</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="flex-basis" src="https://codepen.io/qwguo88/embed/NWWzemV?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/NWWzemV" rel="external nofollow noopener noreferrer" target="_blank">flex-basis</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><blockquote><p> 规定了弹性元素如何伸长或缩短以适应flex容器中的可用空间，它是<code>flex-basis</code>、<code>flex-grow</code>、<code>flex-shrink</code>三个属性的简写形式。可以指定1个，2个或3个值</p></blockquote><p><strong>语法：</strong><br><code>flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ];</code></p><ul><li><code>none</code>：元素会根据自身宽高来设置尺寸。它是完全非弹性的：既不会缩短，也不会伸长来适应 flex 容器。相当于将属性设置为<code>flex: 0 0 auto</code>。</li><li><strong>单值语法：</strong> 值必须为以下其中之一：<ul><li>一个无单位数(number): 它会被当作<code>flex-grow</code>的值。</li><li>一个有效的宽度(width)值: 它会被当作 <code>flex-basis</code> 的值。</li><li>关键字none，auto或initial.</li></ul></li><li><strong>双值语法：</strong> 第一个值必须为一个无单位数，并且它会被当作 <code>flex-grow</code> 的值。第二个值必须为以下之一：<ul><li>一个无单位数：它会被当作 <code>flex-shrink</code> 的值。</li><li>一个有效的宽度值: 它会被当作 <code>flex-basis</code> 的值。</li></ul></li><li><p><strong>三值语法：</strong></p><ul><li>第一个值必须为一个无单位数，并且它会被当作 <code>flex-grow</code> 的值。</li><li>第二个值必须为一个无单位数，并且它会被当作  <code>flex-shrink</code> 的值。</li><li>第三个值必须为一个有效的宽度值， 并且它会被当作 <code>flex-basis</code> 的值。</li></ul></li><li><p><code>initial</code>：元素会根据自身宽高设置尺寸。它会缩短自身以适应 flex 容器，但不会伸长并吸收 flex 容器中的额外自由空间来适应 flex 容器 。相当于将属性设置为<code>flex: 0 1 auto</code>。</p></li><li><code>auto</code>：元素会根据自身的宽度与高度来确定尺寸，但是会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应 flex 容器。这相当于将属性设置为 <code>flex: 1 1 auto</code>.</li></ul><p><strong>兼容性：</strong><br><img src="/2019/12/16/CSS3/flex/flex-caniuse.png" alt="image"><br><a href="https://caniuse.com/#search=flex" rel="external nofollow noopener noreferrer" target="_blank">查看兼容详情</a></p><p>查看案：<a href="https://codepen.io/qwguo88/full/JjjBpWO" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/JjjBpWO</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="flex" src="https://codepen.io/qwguo88/embed/JjjBpWO?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/JjjBpWO" rel="external nofollow noopener noreferrer" target="_blank">flex</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><blockquote><p>定义弹性容器的子项目在显示中的排列顺序，数值越小越靠前，默认值为0。如果两个子项目的 <code>order</code> 值相同那么就按照他们的代码出现结构排序。</p></blockquote><p><strong>语法：</strong><br><code>order: integer;</code></p><ul><li><code>integer</code>：取整数，可以取负数、0、正数。</li></ul><p><strong>兼容性：</strong><br><img src="/2019/12/16/CSS3/flex/flex-order-caniuse.png" alt="image"><br><a href="https://caniuse.com/#feat=mdn-css_properties_order" rel="external nofollow noopener noreferrer" target="_blank">查看兼容详情</a></p><p>查看案：<a href="https://codepen.io/qwguo88/full/rNNrbxb" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/rNNrbxb</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="order" src="https://codepen.io/qwguo88/embed/rNNrbxb?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/rNNrbxb" rel="external nofollow noopener noreferrer" target="_blank">order</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><blockquote><p>可以对弹性容器中的单个子项目进行设置对齐方式，并且覆盖容器中设置的<code>align-items</code>值。</p></blockquote><p><strong>语法：</strong><br><code>align-self: auto | flex-start | flex-end | center | baseline | stretch | inherit</code></p><ul><li><code>auto</code>：按照父元素的 <code>align-items</code> 值对齐，如果该元素没有父元素的话，就设置为 stretch。</li><li><code>flex-start</code>：按照弹性容器的主轴的开始位置对齐。</li><li><code>flex-end</code>：按照弹性容器的主轴结束位置对齐。</li><li><code>center</code>：按照弹性容器的主轴中间对齐。</li><li><code>baseline</code>：按照弹性容器中项目的第一行文字的基线对齐。</li><li><code>stretch</code>：按照弹性容器的宽或者高进行拉伸。</li><li><code>inherit</code>：继承父容器的 <code>align-items</code>对齐方式。</li></ul><p><strong>兼容性：</strong><br><img src="/2019/12/16/CSS3/flex/flex-align-self-caniuse.png" alt="image"><br><a href="https://caniuse.com/#feat=mdn-css_properties_align-self_flex_context" rel="external nofollow noopener noreferrer" target="_blank">查看兼容详情</a></p><p>查看案：<a href="https://codepen.io/qwguo88/full/GRRXxQg" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/GRRXxQg</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="align-self" src="https://codepen.io/qwguo88/embed/GRRXxQg?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/GRRXxQg" rel="external nofollow noopener noreferrer" target="_blank">align-self</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h3 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h3><h4 id="flex在线演示，和在线代码生成网址："><a href="#flex在线演示，和在线代码生成网址：" class="headerlink" title="flex在线演示，和在线代码生成网址："></a>flex在线演示，和在线代码生成网址：</h4><ol><li>在线演示：<a href="https://demos.scotch.io/visual-guide-to-css3-flexbox-flexbox-playground/demos/" rel="external nofollow noopener noreferrer" target="_blank">https://demos.scotch.io/visual-guide-to-css3-flexbox-flexbox-playground/demos/</a></li><li>一个有趣的游戏学习flex布局：<a href="http://flexboxfroggy.com/" rel="external nofollow noopener noreferrer" target="_blank">http://flexboxfroggy.com/</a></li><li>flex布局在线代码生成：<a href="https://the-echoplex.net/flexyboxes/" rel="external nofollow noopener noreferrer" target="_blank">https://the-echoplex.net/flexyboxes/</a></li></ol><h4 id="flex相关文章："><a href="#flex相关文章：" class="headerlink" title="flex相关文章："></a>flex相关文章：</h4><ol><li>阮一峰老师的flex详解：<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></li><li>张鑫旭老师flex详解：<a href="https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhangxinxu.com/wordpress/2018/10/display-flex-css3-css/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
            <tag> flex </tag>
            
            <tag> 弹性布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>columns多列属性</title>
      <link href="/2019/12/13/CSS3/columns/"/>
      <url>/2019/12/13/CSS3/columns/</url>
      
        <content type="html"><![CDATA[<h1 id="columns样式属性使用"><a href="#columns样式属性使用" class="headerlink" title="columns样式属性使用"></a>columns样式属性使用</h1><blockquote><p><code>columns</code>：用于设置元素的列宽和列数。它是<code>column-width</code>和<code>column-count</code>的简写属性。</p></blockquote><p><strong>语法：</strong><br> <code>columns: &lt;&#39;column-width&#39;&gt; || &lt;&#39;column-count&#39;&gt;;</code></p><ul><li><code>column-width</code>：用来设置列宽，取值<code>auto</code>和<code>像素值</code>，实际宽度可能会更宽或更窄以适合可用空间。</li><li><code>column-count</code>：用来设置元素内容被划分成几列，取值<code>auto</code>和<code>正整数</code>。如果取值和列的宽度都非<code>auto</code> ，则它仅指示允许的最大列数。</li></ul><a id="more"></a><p><strong>兼容性：</strong></p><p><img src="/2019/12/13/CSS3/columns/columns-caniuse.png" alt="image"><br><a href="https://caniuse.com/#search=columns" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p><iframe height="400" style="width: 100%;" scrolling="no" title="columns" src="https://codepen.io/qwguo88/embed/jOOagVB?height=400&theme-id=default&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/jOOagVB" rel="external nofollow noopener noreferrer" target="_blank">columns</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h3 id="column-width样式属性使用"><a href="#column-width样式属性使用" class="headerlink" title="column-width样式属性使用"></a>column-width样式属性使用</h3><blockquote><p><code>column-width</code>：用于单独设置元素的列宽。</p></blockquote><p><strong>语法：</strong><br><code>column-width: auto | length;</code></p><ul><li><code>auto</code>：默认值，由浏览器决定宽度。</li><li><code>length</code>：单位值，用来这只每一列的宽度，当设置了<code>column-count</code>的时候优先把内容划分指定列数，宽度将自适应。</li></ul><p><strong>兼容性：</strong></p><p><img src="/2019/12/13/CSS3/columns/column-width-caniuse.png" alt="image"><br><a href="https://caniuse.com/#search=column-width" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p><p>查看案例 <a href="https://codepen.io/qwguo88/pen/poodMNw" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="column-width" src="https://codepen.io/qwguo88/embed/poodMNw?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/poodMNw" rel="external nofollow noopener noreferrer" target="_blank">column-width</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h3 id="column-count样式属性使用"><a href="#column-count样式属性使用" class="headerlink" title="column-count样式属性使用"></a>column-count样式属性使用</h3><blockquote><p><code>column-count</code>：用于单独设置元素的列数。</p></blockquote><p><strong>语法：</strong><br><code>column-count: auto | number;</code></p><ul><li><code>auto</code>：默认值，由其他属性决定列数，比如 <code>column-width</code>，当<code>column-width</code>设置后会根据元素的总宽度和<code>column-width</code>的值来自动划分列数。</li><li><code>number</code>：划分元素以多少列来显示内容。</li></ul><p><strong>兼容性：</strong></p><p><img src="/2019/12/13/CSS3/columns/column-count-caniuse.png" alt="image"><br><a href="https://caniuse.com/#search=column-width" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p><p>查看案例 <a href="https://codepen.io/qwguo88/pen/poodMNw" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="column-width" src="https://codepen.io/qwguo88/embed/poodMNw?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/poodMNw" rel="external nofollow noopener noreferrer" target="_blank">column-width</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="column-gap样式属性使用"><a href="#column-gap样式属性使用" class="headerlink" title="column-gap样式属性使用"></a>column-gap样式属性使用</h2><blockquote><p><code>column-gap</code>：用于设置每一列之间的间隔</p></blockquote><p><strong>语法：</strong><br><code>column-gap: length | normal;</code></p><ul><li><code>length</code>：设置列间的间隔为指定的长度。</li><li><code>normal</code>：规定列间间隔为一个常规的间隔。W3C 建议的值是 1em。</li></ul><p><strong>兼容性：</strong><br><img src="/2019/12/13/CSS3/columns/column-gap-caniuse.png" alt="image"><br><a href="https://caniuse.com/#feat=mdn-css_properties_column-gap_multicol_context" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p><p>查看案例 <a href="https://codepen.io/qwguo88/pen/wvvpNmp" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="column-gap" src="https://codepen.io/qwguo88/embed/wvvpNmp?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/wvvpNmp" rel="external nofollow noopener noreferrer" target="_blank">column-gap</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="column-span样式属性使用"><a href="#column-span样式属性使用" class="headerlink" title="column-span样式属性使用"></a>column-span样式属性使用</h2><blockquote><p><code>column-span</code>：用于设置元素中的子元素横向跨越的列数</p></blockquote><p><strong>语法：</strong><br><code>column-span: 1 | all;</code></p><ul><li><code>1</code>：设置元素横跨一列，默认值。</li><li><code>all</code>：设置元素横跨所有列，也就是单独占一行显示。</li></ul><p><strong>兼容性：</strong><br><img src="/2019/12/13/CSS3/columns/column-span-caniuse.png" alt="image"><br><a href="https://caniuse.com/#search=column-span" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p><p>查看案例 <a href="https://codepen.io/qwguo88/pen/GRRQZQW" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="column-span" src="https://codepen.io/qwguo88/embed/GRRQZQW?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/GRRQZQW" rel="external nofollow noopener noreferrer" target="_blank">column-span</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="column-rule样式属性使用"><a href="#column-rule样式属性使用" class="headerlink" title="column-rule样式属性使用"></a>column-rule样式属性使用</h2><blockquote><p><code>column-rule</code>：字面意思是设置多列规则，它是一个简写属性，用于整体设置所有 <code>column-rule-*</code> 的规则属性，规定列之间的==宽度==、==样式==和==颜色==规则，此属性类似于设置边框。</p></blockquote><p><strong>语法：</strong><br><code>column-rule: width | style | color</code></p><ul><li><p><code>width</code>：规定列之间的宽度规则，非简写：<code>column-rule-width</code></p><ul><li>取值：<code>thin | medium | thick | length</code>;<ul><li><code>thin</code>：很细</li><li><code>medium</code>：中等</li><li><code>thick</code>：宽厚</li><li><code>length</code>：自定义单位值</li></ul></li></ul></li><li><p><code>style</code>：规定列之间的样式规则，非简写：<code>column-rule-style</code></p><ul><li>取值：<code>none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset</code>;<ul><li><code>none</code>：无规则</li><li><code>hidden</code>：隐藏</li><li><code>dotted</code>：点线效果</li><li><code>dashed</code>：虚线效果</li><li><code>solid</code>：实线效果</li><li><code>double</code>：双线效果</li><li><code>groove</code>：定义3D凹槽效果。该效果取决于宽度和颜色值。</li><li><code>ridge</code>：定义3D凸起效果。该效果取决于宽度和颜色值。</li><li><code>inset</code>：定义3D内显示效果。该效果取决于宽度和颜色值。</li><li><code>outset</code>：定义3D外显示效果。该效果取决于宽度和颜色值。</li></ul></li></ul></li><li><p><code>color</code>：规定列之间的颜色规则，非简写：<code>column-rule-color</code></p><ul><li>取值：<code>color</code> 颜色值;</li></ul></li></ul><p><strong>兼容性：</strong></p><p><img src="/2019/12/13/CSS3/columns/column-rule-caniuse.png" alt="image"><br><a href="https://caniuse.com/#search=column-rule" rel="external nofollow noopener noreferrer" target="_blank">查看兼容性详情</a></p><p>查看案例 <a href="https://codepen.io/qwguo88/pen/jOOZrwo" rel="external nofollow noopener noreferrer" target="_blank">Demo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="column-rule" src="https://codepen.io/qwguo88/embed/jOOZrwo?height=300&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/jOOZrwo" rel="external nofollow noopener noreferrer" target="_blank">column-rule</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h2 id="column-fill样式属性使用"><a href="#column-fill样式属性使用" class="headerlink" title="column-fill样式属性使用"></a>column-fill样式属性使用</h2><blockquote><p><code>column-fill</code>：规定如何填充列</p></blockquote><p><strong>语法：</strong><br><code>column-fill: balance | auto;</code></p><ul><li><code>balance</code>：对列进行协调。浏览器应对列长度的差异进行最小化处理。</li><li><code>auto</code>：按顺序对列进行填充，列长度会各有不同。</li></ul><p><strong>兼容性：</strong> 暂时无浏览器支持此属性，这里就不做讨论了。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
            <tag> columns </tag>
            
            <tag> column-gap </tag>
            
            <tag> 布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Grid网格布局</title>
      <link href="/2019/07/20/CSS3/grid/"/>
      <url>/2019/07/20/CSS3/grid/</url>
      
        <content type="html"><![CDATA[<h1 id="css3中的grid布局学习"><a href="#css3中的grid布局学习" class="headerlink" title="css3中的grid布局学习"></a>css3中的grid布局学习</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p>我们这里用我们最熟悉城市街道来理解这些概念。</p></blockquote><ol><li><p>网格容器</p><blockquote><p>一个元素应用网格布局属性后就变成了网格容器，它是由一组水平线和垂直线交叉构成，就如果我们所在的地区有小区和各个路构成。</p></blockquote></li><li><p>网格线</p><blockquote><p>使用Grid布局在显式网格中定义轨道的同时会创建网格线。网格线有水平和垂网格线。也就是东西路段和南北路段的马路。正常情况下<code>n</code>行会有<code>n+1</code>根横向网格线，<code>m</code>列有<code>m+1</code>根纵向网格线。比如<code>田</code>字就是就好像是一个三条水平线和三条垂直线构成的网格元素。</p></blockquote></li></ol><ol start="3"><li><p>网格轨道</p><blockquote><p>网格轨道 是两条网格线之间的空间。</p></blockquote></li><li><p>行</p><blockquote><p>即两个水平网格线之间的空间，也就是水平轨道，就好比我们面朝北边东西方向横向排列的楼房称为行。</p></blockquote></li><li><p>列</p><blockquote><p>即两个垂直网格线之间的空间，也就是垂直轨道，也就是南北方向排列的楼房</p></blockquote></li><li><p>单元格</p><blockquote><p>由水平线和垂直线交叉构成的每个区域称为单元格，网络单元格是CSS网格中的最小单元。也就是说东西和南北方向的路交叉后划分出来的土地区域</p></blockquote></li><li><p>区域</p><blockquote><p>网格区域是网格中由一个或者多个网格单元格组成的一个矩形区域。本质上，网格区域一定是矩形的。例如，不可能创建T形或L形的网格区域。</p></blockquote></li><li><p>网格间距</p><blockquote><p>是网格轨道之间的间距，这里一般值得是列和列，行和行之间的间距</p></blockquote></li><li><p>什么是网格项目</p><blockquote><p>在网格中的所有子元素统称为网格项目，这里只包括子元素，不包括子元素的后代元素。也就是每个区块中的建筑物我们成为网格项</p></blockquote></li></ol><h2 id="应用于父级规则"><a href="#应用于父级规则" class="headerlink" title="应用于父级规则"></a>应用于父级规则</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><blockquote><p>通过给元素设置：<code>display:grid | inline-grid</code>，可以让一个元素变成网格布局元素</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">  display: grid | inline-grid;</code></pre><p><strong>参数说明：</strong></p><ol><li><code>grid</code>：表示把元素定义为块级网格元素，单独占一行;</li><li><code>inline-grid</code>：表示把元素定义为行内块级网格元素，可以和其他块级元素在同一行。</li></ol><h3 id="grid-template-rows-、grid-template-columns"><a href="#grid-template-rows-、grid-template-columns" class="headerlink" title="grid-template-rows 、grid-template-columns"></a>grid-template-rows 、grid-template-columns</h3><blockquote><p>rows 用来规定网格容器的每一行的高度和横向网格线的名称，columns用来规定网格容器的每一列的宽度和纵向网格线的名称</p></blockquote><p><strong>他们的语法相同，所以一起说明</strong></p><p><strong>语法：</strong><br><code>grid-template-rows: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ... ;</code><br><code>grid-template-columns: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ... ;</code></p><p><strong>语法示例：</strong></p><pre><code class="css">/* Keyword value */grid-template-rows: 100px 1fr;grid-template-rows: [linename] 100px;grid-template-rows: [linename1] 100px [linename2 linename3];grid-template-rows: minmax(100px, 1fr);grid-template-rows: fit-content(40%);grid-template-rows: repeat(3, 200px);/* &lt;track-list&gt; values */grid-template-rows: none;grid-template-rows: 200px repeat(auto-fill, 100px) 300px;grid-template-rows: minmax(100px, max-content) repeat(auto-fill, 200px) 20%;grid-template-rows: [linename1] 100px [linename2] repeat(auto-fit, [linename3 linename4] 300px) 100px;grid-template-rows: [linename1 linename2] 100px repeat(auto-fit, [linename1] 300px) [linename3];/* Global values */grid-template-rows: inherit;grid-template-rows: initial;grid-template-rows: unset;</code></pre><p><strong>案例说明：</strong> <a href="https://codepen.io/qwguo88/full/voOdMK" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/voOdMK</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="grid-template-rows or grid-template-columns" src="https://codepen.io/qwguo88/embed/voOdMK?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" loading="lazy"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/voOdMK" rel="external nofollow noopener noreferrer" target="_blank">grid-template-rows or grid-template-columns</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p><strong>我们通过上边案例分析一下取值详情：</strong></p><h4 id="none"><a href="#none" class="headerlink" title="none"></a>none</h4><blockquote><p>这个关键字表示不明确的网格。所有的行和其大小都将由<code>grid-auto-rows</code> 属性隐式的指定。</p></blockquote><p><img src="/2019/07/20/CSS3/grid/row_column_auto.png" alt="image"></p><p>如上图所示，是借助谷歌开发者工具查看，在我们只设置<code>grid-template-rows: auto;</code>和<code>grid-template-columns: auto;</code>属性的情况下，网格项横向100%铺满网格容器，然后纵向排列分部，高度按照项目个数平均分配网格容器总高度。</p><h4 id="length"><a href="#length" class="headerlink" title="length"></a>length</h4><blockquote><p>非负值的长度大小。列（宽度）或者行（高度）值可以是用css绝对单位如：<code>px</code>、<code>em</code>、<code>rem</code>等。</p></blockquote><p><img src="/2019/07/20/CSS3/grid/row_column_length.png" alt="image"></p><p>图上所示，我们设置了<code>grid-template-rows: 100px 50px 200px;</code>和<code>grid-template-columns: 150px 300px 500px;</code>表示把网格容器划分成三行三列的网格，当划分列的宽度总合宽于容器宽度并不会自动换到下一行而且溢出，相应的划分的行总和也一样。</p><h4 id="percentage"><a href="#percentage" class="headerlink" title="percentage"></a>percentage</h4><blockquote><p>非负值且相对于网格容器的 &lt;百分比&gt;<code>%</code>。 如果网格容器的尺寸大小依赖网格轨道的大小（比如 inline-grid ），则百分比值将被视为auto。</p></blockquote><p><img src="/2019/07/20/CSS3/grid/row_column_percentage.png" alt="image"><br>我们在开发的过程中更多的是使用百分百来设置网格划分项，上图是通过设置%+auto的值来划分<code>grid-template-rows: 30% 40% auto;</code>和<code>grid-template-columns: 40% auto 50%;</code>表示把网格容器划分成三行三列，第一行占网格容器的高度的<code>30%</code>，第二行占<code>40%</code>,剩下的高度分配给<code>auto</code>也就是<code>100%-(40%+30%)=30%</code>，同样的列也是如此计算</p><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><blockquote><p>非负值，用单位 <code>fr</code>（fraction 的缩写，意思是”分数”）。表示网格按照给定数字来等分行或者列，当我们划分的行或列单位都用<code>fr</code>的时候表示把网格划分出指定等分</p></blockquote><p><img src="/2019/07/20/CSS3/grid/row_column_fr_1.png" alt="image"></p><p>上图中我们给的值为：<code>grid-template-rows: 1fr 2fr 3fr;</code>和<code>grid-template-columns: 2fr 5fr 1fr;</code>表示三行三列的网格，其中把行分成5等份第一行占<code>1/5</code>第二行占<code>2/5</code>第三行占<code>3/5</code>，把列分成8等份第一列占<code>2/8</code>第二列占<code>5/8</code>第三列占<code>1/8</code></p><p><img src="/2019/07/20/CSS3/grid/row_column_fr_2.png" alt="image"></p><p>上图中我们给的值为：<code>grid-template-rows: 1fr 200px;</code>和<code>grid-template-columns: auto 200px 10% 2fr 3fr;</code>表示两行五列的网格，其中第二行是200像素，第一行占总高度减去<code>200px</code>后的1份，在这个例子中就是<code>300(总高度)-200=100</code>,<code>1fr</code>就是<code>100px</code>高度；<br>列的分配是：第二列是固定的<code>200px</code>，第三列是占总宽度的<code>10%</code>也就是<code>82px</code>，在同时有<code>fr</code>和<code>auto</code>单位的行或列中计算比较特殊，这里的第一列是<code>auto</code>表示取这一列中最多的<code>内容</code>宽度这里就是<code>child-6</code>字符的站位宽，第四列和第五列分别是<code>2fr</code>和<code>2fr</code>表示把剩余的宽度分成5份，一个占剩余宽度的<code>2/5</code>一个占剩余宽度的<code>3/5</code>，在这个例子中表示<code>(820-&#39;child-6字符宽(53)&#39;-200-(820/10))/5 = 97</code>剩余宽度的每一份就是97，第四列就是<code>97*2=194</code>，第五列就是<code>97*3=291</code></p><h4 id="min-content、max-content"><a href="#min-content、max-content" class="headerlink" title="min-content、max-content"></a>min-content、max-content</h4><blockquote><p>一个用来表示以网格项的最大的最小内容来占据网格轨道的关键字。<br>一个用来表示以网格项的最大的内容来占据网格轨道的关键字。</p></blockquote><table><thead><tr><th>chrome</th><th>firefox</th></tr></thead><tbody><tr><td><img src="/2019/07/20/CSS3/grid/row_column_minmax-content_chrome.png" alt="image"></td><td><img src="/2019/07/20/CSS3/grid/row_column_minmax-content_firefox.png" alt="image"></td></tr></tbody></table><p>上图中案例使用：<code>grid-template-rows: 1fr 100px;</code>和<code>grid-template-columns: repeat(2, min-content max-content  minmax(min-content, max-content));</code>表示两行六列的网格；其中行不用说，这里主要说列，列使用了<code>repeat</code>函数来重复；</p><ul><li>第一列和第四列使用的是关键字<code>min-content</code>表示此列的宽度应用此列最宽的单元格中最小内容宽度，怎么理解呢就是这一列中能够自动换行后的最宽文字或者单词，从图上可以看出，Chrome浏览器第一列中在字符<code>child-</code>后面进行了换行然后取的<code>child-</code>这个字符的站位宽度，Firefox浏览器没有在<code>child-</code>后换行。但是在第四列中因为有中文所以两个浏览器都执行了换行，但是换行的位置有所不同。</li><li>第二列和第五列使用的是关键字<code>max-content</code>表示此列的宽度应用此列最宽的单元格最大内容宽度，意思是内容尽量不自定换行然后取最大内容字符的宽度作为此列的宽度。</li><li>第三列和第六列使用的是minmax()函数定义列宽，里边最大最小值也是应用了<code>min-content</code>和<code>max-content</code>这里去的是最大内容宽度</li></ul><h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h4><blockquote><p>此方法可以让我们用一种简单快捷的方式划分比较多而且有规律的网格单元格，比如说我们要划分一个1行12列网格，如果我们划分的列宽很有规律，我没必要写12遍</p></blockquote><ul><li><p><strong>此方法语法：</strong> <code>repeat( [ &lt;positive-integer&gt; | auto-fill | auto-fit ] , &lt;track-list&gt; )</code></p></li><li><p><strong>参数说明</strong></p><ul><li><code>positive-integer</code>：表示要重复的<code>track-list</code>规则次数</li><li><code>auto-fit</code>：用于不确定列的情况下，当<code>track-list</code>规则指定的所有子元素宽度之和不大于网格容器总宽度时平均拉升子元素填充剩余空间</li><li><code>auto-fill</code>：用于不确定列的情况下，当<code>track-list</code>规则指定的所有子元素宽度之和不大于网格容器总宽度时子元素不拉升填充剩余空间</li></ul></li><li><p><strong>图例：</strong><br><img src="/2019/07/20/CSS3/grid/row_column_repeat_length.png" alt="image"><br>上图案例中我们给的值为：<code>grid-template-rows: repeat(2, 100px);</code>和<code>grid-template-columns: repeat(2, 100px 1fr auto);</code>表示两行六列的网格，其中两行的高度都是<code>100px</code>，这里使用<code>repeat()</code>函数表示重复定义，第一个参数表示重复次数，第二个参数表示要重复的值，多个值用空格隔开，案例表示划分2行每行都是100像素的行，从图上可以看出两行高度加起来不大于网格容器高度所以空出来留给网格中多出来的子项目；其中六列的宽度分别是第一列和第四列宽度为<code>100px</code>第三列和第六列宽度为该列中最长字符占位宽度，第二列和第五列宽度为<code>(820-(100px*2)-(&#39;child-3&#39;字符宽+&#39;child-6&#39;字符宽)/2)</code>，第二个参数为多个值得时候表示按照循序分配第一个参数的次数。</p><p><img src="/2019/07/20/CSS3/grid/row_column_repeat_auto-fit.png" alt="image"><br>上图案例中取值为：<code>grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));</code> 我们使用<code>auto-fit</code>关键字不固定列，同时每一列宽度最小值为<code>100px</code>最大值为<code>1fr</code>，因为子项取最小值总合加起来不大于容器宽度，所以每个子项都拉升填满整个容器。</p><p><img src="/2019/07/20/CSS3/grid/row_column_repeat_auto-fill.png" alt="image"><br>上图案例中取值为：<code>grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));</code> 我们使用<code>auto-fill</code>关键字不固定列，同时每一列宽度最小值为<code>100px</code>最大值为<code>1fr</code>，每个子项取最小值综合加起来不大于容器宽度，这个时候继续按照最小值分隔列，直到剩余宽度不大于<code>100px</code>，然后所以每个子项再平均分隔剩余空间。</p></li></ul><h4 id="minmax-min-max"><a href="#minmax-min-max" class="headerlink" title="minmax(min, max)"></a>minmax(min, max)</h4><blockquote><p>此方法表示取值一个范围，最小值和最大值，大于等于min值，并且小于等于max值。如果max值小于min值，则该值会被视为min值。最大值可以设置为网格轨道系数值<flex> ，但最小值则不行。</flex></p></blockquote><p><img src="/2019/07/20/CSS3/grid/row_column_minmax.png" alt="image"></p><p>上图案例中我们使用<code>minmax()</code>函数定义值：<code>grid-template-rows: minmax(100px, 1fr) 150px;</code>和<code>grid-template-columns: repeat(2, 100px 1fr minmax(100px, auto));</code>表示两行六列的网格，其中行中因为有固定值,所以第二行高度<code>150px</code>，然后第一行中的<code>minmax()</code>方法再根据剩余空间计算取值，如果剩余高度大于最小值<code>100px</code>那么就取<code>1fr</code>，如果剩余高度小于最小值<code>100px</code>那么高度取<code>100px</code>，当此方法第二个参数是固定值时，如果剩余高度大于这个固定值，那么高度取最大值得固定值。</p><h4 id="fit-content"><a href="#fit-content" class="headerlink" title="fit-content()"></a>fit-content()</h4><blockquote><p>字面理解是<code>fit</code>适合后面跟内容，就是适合内容宽度，这里我测试的是不超过给定值得宽度（当给定宽度不大于内容最小宽度时会超过），同时固定值分配宽度后的剩余宽度小于给定值时候自动缩小宽度但是不能小于换行后的最宽项的最小内容宽度。</p></blockquote><table><thead><tr><th>Chrome</th><th>Firefox</th></tr></thead><tbody><tr><td><img src="/2019/07/20/CSS3/grid/row_column_fit-content_chrome.png" alt="image"></td><td><img src="/2019/07/20/CSS3/grid/row_column_fit-content_firefox.png" alt="image"></td></tr></tbody></table><p>上图案例中我们使用<code>fit-content()</code>函数定义列值：<code>grid-template-columns: fit-content(10px) fit-content(70px) 50% 35%;</code>表示第一列按内容计算宽度最大值为<code>10px</code>但是截图中第一列的换行后的最小宽度<code>child-</code>字符已经超过<code>10px</code>所以宽度取值为<code>child-</code>字符宽度，第二列给定按内容计算宽度最大值为<code>70px</code>这个时候此列取值为<code>70px</code>并且此列的所有项都能在<code>70px</code>内换行，第三列宽度是固定的总宽度的50%：<code>820px*0.5=410px</code>，第四列宽度是总宽度的30%：<code>820px*0.35=287px</code>；</p><h4 id="line-name"><a href="#line-name" class="headerlink" title="[line-name]"></a>[line-name]</h4><blockquote><p>定义垂直和水平线的名称，同时可以使用多个名字来命名一条分隔线，多个名字之间用空格分开，给分隔线命名的字符必须用<code>[]</code>括起来，网格线的作用是为了网格中网格项目的定位使用。</p></blockquote><pre><code class="css">grid-template-rows: [row-one-start] 30% [row-one-end row-two-start] 40% [row-two-end row-three-start] auto [row-three-end];grid-template-columns: repeat(3, 33% [col-line]);</code></pre><p>上面的代码定义了三行三列的网格那么网格线分别有4条横向和4条纵向，并且给网格线起了名字。<br>分别表示给横向网格线的第一条线命名为<code>row-one-start</code>，第二条网格线命名为两个名字<code>row-one-end</code>和<code>row-tow-start</code>，第三条网格线命名为<code>row-two-end</code>和<code>row-three-start</code>，第四条网格线命名为<code>row-three-end</code>；纵向使用了<code>repeat()</code>方法重复定义了三列，同时四条纵向的网格线名称都定义为了相同的名称<code>col-line</code>。</p><p>当我们不给网格线定义名称的情况下浏览器会从1开始自动递增生成网格线名称，我们可以借助下图查看<br><img src="/2019/07/20/CSS3/grid/line-name_auto.png" alt="image"><br>上图是截取的Firefox的调试工具，可以看出最左边的第一条纵向线名称为1，最上边的第一条横向网格线名称也是1。</p><h3 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a>grid-template-areas</h3><p>通过字面理解area是区域的意思，这个属性的作用是给网格布局容器划分区域。</p><p><strong>语法：</strong><code>grid-template-areas:  &quot;&lt;grid-area-name&gt; | . | none | ...&quot; &quot;...&quot;;</code></p><p><strong>取值说明：</strong></p><ol><li><code>grid-area-name</code>：给区域定义名称，这里主要按照行来定义用双引号或者单元号括起来代表一行，一行中多列可以定义相同的名称(代表同一个区块)或不同名称（代表不同区块），名称之间用空格分开，第二行</li><li><code>.</code>：表示空网格区块</li><li><code>none</code>：表示没有定义网格区块名称</li></ol><p><strong>案例说明：</strong> <a href="https://codepen.io/qwguo88/full/ZgBXoE" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/ZgBXoE</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="grid-template-areas" src="https://codepen.io/qwguo88/embed/ZgBXoE?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true" loading="lazy"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/ZgBXoE" rel="external nofollow noopener noreferrer" target="_blank">grid-template-areas</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p>在这里我们借助Firefox工具查看我们定义的区块划分：</p><p><img src="/2019/07/20/CSS3/grid/grid-template-areas_1.png" alt="image"></p><p>在上图中我们定义了：<code>grid-template-areas: &#39;head head head&#39; &#39;. body-content body-right&#39; &#39;foot foot none&#39;</code>，从图中我们可以看到第一行划分了一个区块，区块名<code>head</code>占据三列，第二行划分了三个区块左边的是用<code>.</code>划分的空区块，中间的区块名：<code>body-content</code>，右边的区块名：<code>body-right</code>，第三行划分了两个区块，左边的区块名：<code>foot</code>占据两列，右边的区块名：<code>none</code>没有名称占据一列<br>我们给定了网格区域名称以后，可以通过给子元素（网格单元格）设置<code>grid-area:head</code>进行设置一个单元格所占空间，属性名不用使用引号。</p><p><img src="/2019/07/20/CSS3/grid/grid-template-areas_2.png" alt="image"></p><p>上图是我们通过给子元素设置区块名称得到的效果，子元素设置区块名我们将在后面进行介绍。</p><!--**注意：**如果我们给网格区域命了名，但是没有给网格线命名，则会自动根据网格区域名称生成网格线名称，规则是区域名称后面加-start和-end。例如，某网格区域名称是`'a'`，则左侧column线名称就是`'a-start'`，左侧column线名称就是`'a-end'`。我们的网格区域一定要形成规整的矩形区域，什么L形，凹的或凸的形状都是不支持的，会认为是无效的属性值。 --><h3 id="grid-template"><a href="#grid-template" class="headerlink" title="grid-template"></a>grid-template</h3><p><code>grid-template</code>是<code>grid-template-row</code>、<code>grid-template-column</code>、<code>grid-template-area</code>的简写形式</p><p><strong>语法：</strong></p><pre><code class="css">/* 值为关键词 */grid-template: none;/* 为 grid-template-rows / grid-template-columns */grid-template: 100px 1fr / 50px 1fr;grid-template: auto 1fr / auto 1fr auto;grid-template: [linename] 100px / [columnname1] 30% [columnname2] 70%;grid-template: fit-content(100px) / fit-content(40%);/* 为 grid-template-areas grid-template-rows / grid-template-column */grid-template: &quot;a a a&quot;               &quot;b b b&quot;;grid-template: &quot;a a a&quot; 20%               &quot;b b b&quot; auto;grid-template: [header-top] &quot;a a a&quot;     [header-bottom]               [main-top] &quot;b b b&quot; 1fr [main-bottom]                            / auto 1fr auto;/* 为全局值 */grid-template: inherit;grid-template: initial;grid-template: unset;</code></pre><p><strong>案例说明：</strong> <a href="https://codepen.io/qwguo88/full/ZgBXoE" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/ZgBXoE</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="grid-template" src="https://codepen.io/qwguo88/embed/pMwBpv?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/pMwBpv" rel="external nofollow noopener noreferrer" target="_blank">grid-template</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p>从案例中可以看到，<code>grid-template</code>定义行或者列要简单很多 行和列之间用<code>/</code>分开，前面的部分是定义的<code>grid-template-rows</code>后面的部分是定义的<code>grid-template-columns</code>，还可以只定义区块，然后网格会根据给定的规则等比例划网格。</p><p>这里我们介绍一下引用区块划分的代码，效果图如下</p><p><img src="/2019/07/20/CSS3/grid/grid-template-area_3.png" alt="image"></p><p>上图引用的代码是：<code>grid-template: &quot;a a c&quot; &quot;b b c&quot;;</code>只给网格容器划分区块，此代码给网格容器划分了两行三列，第一行的第一列和第二列合并成一个区块，第二行的第一列和第二列合并成一个区块，第一行的第三列和第二行的第三列竖向合并一个区块。然后通过给子项目应用区块。</p><p><img src="/2019/07/20/CSS3/grid/grid-template-area_4.png" alt="image"></p><p>上图引用的代码是：<code>grid-template: &quot;a a a&quot; 40px &quot;b c c&quot; 40px &quot;b c c&quot; 40px / 1fr 1fr 1fr;</code>代码说明<code>/</code>前面的属于行划分，第一行划分成一个区块<code>a</code>高度为<code>40px</code>，第二行划分成两个区块<code>b</code>和<code>c</code>高度也是<code>40px</code>，第三行划分成两个区块<code>b</code>和<code>c</code>高度也是<code>40px</code>，第二行和第三行的第一列区块属于一个所以上下合并，第二行和第三行的第二列第三列区块一样整体合并。<code>/</code>后面的列规定按照整体宽度划分为三份每列的宽度是1/3。</p><h3 id="grid-column-gap、grid-row-gap"><a href="#grid-column-gap、grid-row-gap" class="headerlink" title="grid-column-gap、grid-row-gap"></a>grid-column-gap、grid-row-gap</h3><blockquote><p>此属性分别定义列和列之间的间距、行和行之间的间距</p></blockquote><table><thead><tr><th>Chrome</th><th>Firefox</th></tr></thead><tbody><tr><td><img src="/2019/07/20/CSS3/grid/grid-row-gap_1_chrome.png" alt="image"></td><td><img src="/2019/07/20/CSS3/grid/grid-row-gap_1_firefox.png" alt="image"></td></tr></tbody></table><p>图上我们定义了：三行三列的网格，<code>grid-row-gap: 10px;</code>给行与行之间定义<code>10px</code>的间距，图中我们借助Firefox可以看虚斜线的区域属于行与行之间的间距区域。</p><table><thead><tr><th>Chrome</th><th>Firefox</th></tr></thead><tbody><tr><td><img src="/2019/07/20/CSS3/grid/grid-column-gap_1_chrome.png" alt="image"></td><td><img src="/2019/07/20/CSS3/grid/grid-column-gap_1_firefox.png" alt="image"></td></tr></tbody></table><p>图上我们定义了：三行三列的网格，<code>grid-column-gap: 10px;</code>给列与列之间定义<code>10px</code>的间距，图中我们借助Firefox可以看虚斜线的区域属于列与列之间的间距区域。</p><h3 id="grid-gap"><a href="#grid-gap" class="headerlink" title="grid-gap"></a>grid-gap</h3><blockquote><p>他是<code>grid-column-gap</code>和<code>grid-row-gap</code>的简写形式，如果提供一个值，那么应用于行和列的间距，如果提供两个值需要用空格分开，空格前边的是行间距，空格后边的是列间距<br><img src="/2019/07/20/CSS3/grid/grid-gap_1_firefox.png" alt="image"></p></blockquote><p>上图我们给的定义是：<code>grid-gap: 20px 10px</code>;表示网格的行间距是<code>20px</code>列间距是<code>10px</code>;</p><h3 id="grid-auto-rows-or-grid-auto-columns"><a href="#grid-auto-rows-or-grid-auto-columns" class="headerlink" title="grid-auto-rows or grid-auto-columns"></a>grid-auto-rows or grid-auto-columns</h3><blockquote><p>此属性定义了，子项目的个数超出了我们定义的行和列的情况下，多出的子项目的宽度高度的尺寸大小；</p></blockquote><p><img src="/2019/07/20/CSS3/grid/grid-auto-rows_firefox.png" alt="image"></p><p>上图我们给定的规则是：<code>grid-template-rows: 20px 30px 40px;</code>和<code>grid-auto-rows: 80px;</code>，我们给网格元素划分了三行，每一行都给定了高度，网格中有5个子元素。从图上可以看出前三个子深色虚线的行是我们规定好的高度，中间实线一下的浅色点虚线是应用的<code>grid-auto-rows</code>定义的<code>80px</code>高度。</p><table><thead><tr><th>Chrome</th><th>Firefox</th></tr></thead><tbody><tr><td><img src="/2019/07/20/CSS3/grid/grid-auto-columns_chrome.png" alt="image"></td><td><img src="/2019/07/20/CSS3/grid/grid-auto-columns_firefox.png" alt="image"></td></tr></tbody></table><p>要解释<code>grid-auto-columns</code>属性需要用区域定义属性，上图效果中我们定义了<code>grid-template: &#39;a b c d e f g&#39; / 90px 90px 90px;</code>一行7个区域(隐式定义了7类)的网格，但是我们只定义了前三列<code>90px</code>的宽度，并且占据了前三个区域a、b、c，剩下的两个子元素和多余的区域宽度将会应用我们定义的<code>grid-auto-columns: 50px;</code>；这是的chrome和Firefox表现一直，宽度都是50像素。</p><h3 id="grid-auto-flow"><a href="#grid-auto-flow" class="headerlink" title="grid-auto-flow"></a>grid-auto-flow</h3><blockquote><p>控制子元素的排列顺序，默认子元素排序是按照自左到右自上而下一行一行排列。</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">/* Keyword values */grid-auto-flow: row;grid-auto-flow: column;grid-auto-flow: dense;grid-auto-flow: row dense;grid-auto-flow: column dense;/* Global values */grid-auto-flow: inherit;grid-auto-flow: initial;grid-auto-flow: unset;</code></pre><p><strong>取值说明：</strong></p><ol><li><code>row</code>：按行顺序排列，默认值，子元素出现的顺序先填充行，第一行填充完毕，在填充第二行；</li><li><code>column</code>：按照列顺序排列，子元素出现的顺序先填充列，第一列填充完毕，在填充第二列</li><li><code>dense</code>：该关键字使用一种“稠密”堆积算法，如果后面出现了稍小的元素，则会试图去填充网格中前面留下的空白。这样做会填上稍大元素留下的空白，但同时也可能导致原来出现的次序被打乱。</li><li><code>row dense</code>：和<code>dense</code>值基本相同</li><li><code>column dense</code>：这个是纵向“稠密””堆积算法；</li></ol><p><strong>案例说明：</strong> <a href="https://codepen.io/qwguo88/full/OJyzQLj" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/OJyzQLj</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="grid-auto-flow" src="https://codepen.io/qwguo88/embed/OJyzQLj?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/OJyzQLj" rel="external nofollow noopener noreferrer" target="_blank">grid-auto-flow</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h3 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h3><blockquote><p>基本布局分析完毕，我们来说一下网格容器中的对齐方式，网格中对齐方式有：</p></blockquote><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><blockquote><p>是指网格项目元素在单元格中的垂直呈现方式，是垂直拉伸显示，还是上中下对齐</p></blockquote><table><thead><tr><th>chrome</th><th>Firefox</th></tr></thead><tbody><tr><td><img src="/2019/07/20/CSS3/grid/align-items_chrome.png" alt="image"></td><td><img src="/2019/07/20/CSS3/grid/align-items_firefox.png" alt="image"></td></tr></tbody></table><p>我们还是可以借助上面的截图图片再结合下边的案例来理解各个取值的区别，图中虚线的位置代表的是网格的单元格，色块代表的是网格项目</p><p><strong>案例演示：</strong> <a href="https://codepen.io/qwguo88/full/jObYKzd" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/jObYKzd</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="grid-align-items" src="https://codepen.io/qwguo88/embed/jObYKzd?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/jObYKzd" rel="external nofollow noopener noreferrer" target="_blank">grid-align-items</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h4 id="justify-items"><a href="#justify-items" class="headerlink" title="justify-items"></a>justify-items</h4><blockquote><p>是指网格项目元素在单元格中的水平呈现方式，是水平拉伸显示，还是左中右对齐</p></blockquote><table><thead><tr><th>chrome</th><th>Firefox</th></tr></thead><tbody><tr><td><img src="/2019/07/20/CSS3/grid/justify-items_chrome.png" alt="image"></td><td><img src="/2019/07/20/CSS3/grid/justify-items_firefox.png" alt="image"></td></tr></tbody></table><p>我们可以借助上面的截图图片再结合下边的案例来理解各个取值的区别，图中虚线的位置代表的是网格的单元格，色块代表的是网格项目</p><p><strong>案例演示：</strong> <a href="https://codepen.io/qwguo88/full/JjYMvMz" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/JjYMvMz</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="grid-justify-items" src="https://codepen.io/qwguo88/embed/JjYMvMz?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/JjYMvMz" rel="external nofollow noopener noreferrer" target="_blank">grid-justify-items</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p>通过上边的案例我们发现，一般使用 <code>stretch</code>、<code>start</code>、<code>end</code>、<code>center</code>这几个值，<code>stretch</code>是默认值</p><h4 id="place-items"><a href="#place-items" class="headerlink" title="place-items"></a>place-items</h4><blockquote><p>此属性是 <code>align-items</code>和<code>justify-items</code>的缩写形式</p></blockquote><p><strong>语法</strong></p><pre><code class="css">/* 单个值 */place-items: center;/* 两个值 */place-items: align-items justify-items;</code></pre><p><strong>说明：</strong><br>如果是单个值的情况下，将应用于垂直和水平对齐，如果是两个值的话需要用空格分开，前边的表示垂直对齐，后边的表示水平对齐。</p><table><thead><tr><th>chrome</th><th>Firefox</th></tr></thead><tbody><tr><td><img src="/2019/07/20/CSS3/grid/place-items_chrome.png" alt="image"></td><td><img src="/2019/07/20/CSS3/grid/place-items_firefox.png" alt="image"></td></tr></tbody></table><p>我们还是可以借助上面的截图图片再结合下边的案例来理解各个取值的区别，图中虚线的位置代表的是网格的单元格，色块代表的是网格项目</p><p><strong>案例演示：</strong> <a href="https://codepen.io/qwguo88/full/ExVoRJy" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/ExVoRJy</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="grid-place-items" src="https://codepen.io/qwguo88/embed/ExVoRJy?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/ExVoRJy" rel="external nofollow noopener noreferrer" target="_blank">grid-place-items</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><blockquote><p>指的是把网格布局中的所以子项成一个整体，然后让整体在网格容器中垂直对齐，这个需要两行以上才能看到效果。</p></blockquote><table><thead><tr><th>center</th><th>start</th><th>end</th></tr></thead><tbody><tr><td><img src="/2019/07/20/CSS3/grid/align-content_center.png" alt="image"></td><td><img src="/2019/07/20/CSS3/grid/align-content_start.png" alt="image"></td><td><img src="/2019/07/20/CSS3/grid/align-content_end.png" alt="image"></td></tr></tbody></table><p>我们还是结合上图Firefox截图理解各个支的表现形式。在图上我们可以看到，取值为<code>start</code>的时候网格项整体会靠上显示，取值为<code>center</code>的时候网格项整体的上边会填充<code>gap</code>使其整体垂直居中显示，取值为<code>end</code>的时候所取的<code>gap</code>会更大，使网格项整体靠下对齐。他可取的值还有很多，我们可以结合下边的实例来查看效果。</p><p><strong>案例展示：</strong><a href="https://codepen.io/qwguo88/full/mdeXWxy" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/mdeXWxy</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="grid-align-content" src="https://codepen.io/qwguo88/embed/mdeXWxy?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/mdeXWxy" rel="external nofollow noopener noreferrer" target="_blank">grid-align-content</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><blockquote><p>指的是把网格布局中的所以子项成一个整体，然后让整体在网格容器中水平对齐，这个需要两列以上才能看到效果。</p></blockquote><table><thead><tr><th>center</th><th>start</th><th>end</th></tr></thead><tbody><tr><td><img src="/2019/07/20/CSS3/grid/justify-content_center.png" alt="image"></td><td><img src="/2019/07/20/CSS3/grid/justify-content_start.png" alt="image"></td><td><img src="/2019/07/20/CSS3/grid/justify-content_end.png" alt="image"></td></tr></tbody></table><p>我们还是结合上图Firefox截图理解各个支的表现形式。在图上我们可以看到，取值为<code>start</code>的时候网格项整体会靠左显示，取值为<code>center</code>的时候网格项整体的左边会填充<code>gap</code>使其整体水平居中显示，取值为<code>end</code>的时候所取的<code>gap</code>会更大，使网格项整体靠右对齐。他可取的值还有很多，我们可以结合下边的实例来查看效果。</p><p><strong>案例展示：</strong><a href="https://codepen.io/qwguo88/full/ExVopyW" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/ExVopyW</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="grid-justify-content" src="https://codepen.io/qwguo88/embed/ExVopyW?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/ExVopyW" rel="external nofollow noopener noreferrer" target="_blank">grid-justify-content</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h4 id="place-content"><a href="#place-content" class="headerlink" title="place-content"></a>place-content</h4><blockquote><p>此属性是 <code>align-content</code>和<code>justify-content</code>的缩写形式</p></blockquote><p><strong>语法</strong></p><pre><code class="css">/* 单个值 */place-content: center;/* 两个值 */place-content: align-content justify-content;</code></pre><p><strong>说明：</strong><br>如果是单个值的情况下，将应用于垂直和水平对齐，如果是两个值的话需要用空格分开，前边的表示垂直对齐，后边的表示水平对齐。</p><table><thead><tr><th>start</th><th>center</th><th>end</th></tr></thead><tbody><tr><td><img src="/2019/07/20/CSS3/grid/place-content_start.png" alt="image"></td><td><img src="/2019/07/20/CSS3/grid/place-content_center.png" alt="image"></td><td><img src="/2019/07/20/CSS3/grid/place-content_end.png" alt="image"></td></tr></tbody></table><p>我们还是可以借助上面的截图图片再结合下边的案例来理解各个取值的区别</p><p><strong>案例演示：</strong> <a href="https://codepen.io/qwguo88/full/JjYpvex" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/JjYpvex</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="grid-place-content" src="https://codepen.io/qwguo88/embed/JjYpvex?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/JjYpvex" rel="external nofollow noopener noreferrer" target="_blank">grid-place-content</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h3 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h3><blockquote><p>grid 是一个简写属性，它可以用来设置以下属性：显式网格属性 <code>grid-template-rows</code>、<code>grid-template-columns</code> 和 <code>grid-template-areas</code>， 隐式网格属性 <code>grid-auto-rows</code>、<code>grid-auto-columns</code> 和  <code>grid-auto-flow</code>， 间距属性 <code>grid-column-gap</code> 和 <code>grid-row-gap</code>。</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">/*最简单理解*/grid: row/column; /* / 先前面的都是指行，右边的都指的是列*/grid: [ auto-flow &amp;&amp; dense? ] &lt;grid-auto-rows&gt;? / &lt;grid-template-columns&gt;grid: &lt;grid-template-rows&gt; / [ auto-flow &amp;&amp; dense? ] &lt;grid-auto-columns&gt;?/* &lt;&#39;grid-template&#39;&gt; values */grid: none;grid: &quot;a&quot; 100px &quot;b&quot; 1fr;grid: [linename1] &quot;a&quot; 100px [linename2];grid: &quot;a&quot; 200px &quot;b&quot; min-content;grid: &quot;a&quot; minmax(100px, max-content) &quot;b&quot; 20%;grid: 100px / 200px;grid: minmax(400px, min-content) / repeat(auto-fill, 50px);/* &lt;&#39;grid-template-rows&#39;&gt; /   [ auto-flow &amp;&amp; dense? ] &lt;&#39;grid-auto-columns&#39;&gt;? values */grid: 200px / auto-flow;grid: 30% / auto-flow dense;grid: repeat(3, [line1 line2 line3] 200px) / auto-flow 300px;grid: [line1] minmax(20em, max-content) / auto-flow dense 40%;/* [ auto-flow &amp;&amp; dense? ] &lt;&#39;grid-auto-rows&#39;&gt;? /   &lt;&#39;grid-template-columns&#39;&gt; values */grid: auto-flow / 200px;grid: auto-flow dense / 30%;grid: auto-flow 300px / repeat(3, [line1 line2 line3] 200px);grid: auto-flow dense 40% / [line1] minmax(20em, max-content);</code></pre><h2 id="应用在网格项目上"><a href="#应用在网格项目上" class="headerlink" title="应用在网格项目上"></a>应用在网格项目上</h2><h3 id="grid-column-start、grid-column-end"><a href="#grid-column-start、grid-column-end" class="headerlink" title="grid-column-start、grid-column-end"></a>grid-column-start、grid-column-end</h3><blockquote><p>指定网格项目从哪个纵向网格线开始，到那个纵向网格线结束，同时也可以设置夸多少列</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">grid-column-start: start-line-name | number | span number;grid-column-end: end-line-name | number | span number;</code></pre><ol><li><code>start-line-name</code>和 <code>end-line-name</code>：表示纵向的网格线名称；</li><li><code>number</code>：表示没有给网格线起名的情况下使用数字表示；</li><li><code>span</code>：表示跨越的意思，后边的数字表示跨越几列；</li></ol><p>结合案例和图片我们来看一下具体用法：</p><p><strong>案例展示：</strong><a href="https://codepen.io/qwguo88/full/gOavJVo" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/gOavJVo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="grid-column-start-end" src="https://codepen.io/qwguo88/embed/gOavJVo?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/gOavJVo" rel="external nofollow noopener noreferrer" target="_blank">grid-column-start-end</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p>图我们还是借助Firefox开发者工具，我们在没有设置网格线名称的情况下显示网格线的数字号，这样可以更容易理解；此示例我们都是使用的三行三列的网格布局。</p><p><img src="/2019/07/20/CSS3/grid/grid-column-start_1.png" alt="image"></p><p>上图中我们只设置了网格子项的<code>grid-column-start</code>属性，</p><ol><li><code>child-1</code>我们设置了<code>grid-column-start: 1;</code>也就是此项列的开始位置是第1条纵向网格线，如果我们给网格线定义名称我们这也可以使用网格线名字来标记，这里并没有设置<code>grid-column-end</code>属性，那么子项默认在第2条纵向网格线结束，占据一列位置，也就是得出结论只设置start但是没设置end，默认end = start+1。</li><li><code>child-2</code>我们设置了<code>grid-column-start: 3;</code>此项从第3条纵向网格线开始，跨越一列结束在最后一条网格线。</li><li><code>child-3</code>我们也设置了<code>grid-column-start: 3;</code>此项从第3条网格线开始，由于第二个子元素已经占据了最后一列，所以这一个子项将从第二行开始计算，在第二行的第3条纵向网格线开始到第4个结束。这一字项的开始位置在不大于最后一个纵向线条数值，会自动换到下一列显示。</li></ol><p><img src="/2019/07/20/CSS3/grid/grid-column-end_1.png" alt="image"></p><p>上图中我们只设置了网格子项的<code>grid-column-end</code>属性，通过设置结束位置来布局子项位置，在只设置end的情况下start = end -1；同时他也是当占据一行的最后一列时，如果后边元素结束位置不大于最后一个纵向线条数值，会自动换到下一列显示。</p><p><img src="/2019/07/20/CSS3/grid/grid-column-start_2.png" alt="image"></p><p>上图中我们设置得子项开始位置都超过了纵向线条得总个数，这个时候可以看出，给第一个设置了<code>grid-column-start: 5;</code>表示从第5条纵向网格线开始，由于没设置end所以跨越一列，并且隐式给网格增加了两列，此时后边的项设置start位置的时候如果不大于5，那么会从第二行开始。<br>相应的<code>grid-column-end</code>也是同样效果。</p><p><img src="/2019/07/20/CSS3/grid/grid-column-start-end_1.png" alt="image"></p><p>当两个属性结合使用表示，子元素左边从第几个网格线开始，右边到第几个线条结束，中间跨越开始和结束之间的列，如果结束的列大于网格纵向线条个数会自用增加隐式列。途中<code>child-1</code>设置了<code>grid-column-start: 2;      grid-column-end: 5;</code>从第2个纵向线开始到第5个纵向线结束，所以中间自动增加一列。</p><p><img src="/2019/07/20/CSS3/grid/grid-column-start-span.png" alt="image"></p><p>上图我们使用了关键字<code>span</code>表示跨几列得意思。</p><ol><li><code>child-1</code>设置了<code>grid-column-start: span 2;</code>表示从默认的开始位置跨越两列位置。</li><li><code>child-2</code>设置了<code>grid-column-start: 2;grid-column-end: span 3;</code>表示从第第2个纵向线开始结束线跨越3列，在这里也会隐式增加一列，因为总列数只有三列。</li></ol><p>如果命名了网格线名称，上边的数字换成网格线对应的名称就可以了，这里需要注意的是，如果给定一个没有名称的网格线，那么他会从最后一条网格线开始，相当于隐式增加列。</p><h3 id="grid-row-start、grid-row-end"><a href="#grid-row-start、grid-row-end" class="headerlink" title="grid-row-start、grid-row-end"></a>grid-row-start、grid-row-end</h3><blockquote><p>指定网格项目从哪个横线网格线开始，到那个列横线网格线结束，同时也可以设置夸多行</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">grid-row-start: start-line-name | number;grid-row-end: end-line-name | number;</code></pre><ol><li><code>start-line-name</code>和 <code>end-line-name</code>：表示横向的网格线名称；</li><li><code>number</code>：表示没有给网格线起名的情况下使用数字表示；</li><li><code>span</code>：表示跨越的意思，后边的数字表示跨越几行；</li></ol><p>横线网格线开始和结束和纵向基本差不多，只是在方向上有所不同，横线网格会设置大于总横线网格线会自用增加行数，他默认的<code>grid-column-start</code>是第1条纵向网格，他会总动在第列开始下一个子项等。</p><p><strong>案例展示：</strong><a href="https://codepen.io/qwguo88/full/mdexLRo" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/mdexLRo</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="grid-row-start-end" src="https://codepen.io/qwguo88/embed/mdexLRo?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/mdexLRo" rel="external nofollow noopener noreferrer" target="_blank">grid-row-start-end</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><h3 id="grid-row、grid-column"><a href="#grid-row、grid-column" class="headerlink" title="grid-row、grid-column"></a>grid-row、grid-column</h3><blockquote><p>他们是一种缩写形式，<code>grid-row</code>是 <code>grid-row-start</code>和<code>grid-row-end</code>的缩写，<code>grid-column</code>是<code>grid-column-start</code>和<code>grid-column-end</code>的缩写。中间值用<code>/</code>分割</p></blockquote><p><strong>语法：</strong></p><pre><code class="css">grid-row: line-name | numbergrid-row: line-name | number / line-name | number | span numbergrid-column: line-name | numbergrid-column: line-name | number / line-name | number | span number</code></pre><p><strong>案例展示：</strong><a href="https://codepen.io/qwguo88/full/YzyLxLR" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/YzyLxLR</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="grid-row、grid-column" src="https://codepen.io/qwguo88/embed/YzyLxLR?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/YzyLxLR" rel="external nofollow noopener noreferrer" target="_blank">grid-row、grid-column</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p>通过上边的案例我的得知，当该属性取一个值的时候表示<code>start</code>并且子项占一行或者一列；当<code>end</code>的值小于<code>start</code>值得时候，两个值互换。</p><h3 id="grid-area"><a href="#grid-area" class="headerlink" title="grid-area"></a>grid-area</h3><p><strong>语法：</strong></p><pre><code class="css">grid-area: area-name;grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</code></pre><ol><li><code>name</code>：表示区域的名称；</li><li><code>row-start</code>和<code>row-end</code>：横向网格线名称；</li><li><code>column-start</code>和<code>column-end</code>：纵向网格线名称；</li></ol><p><strong>案例展示：</strong><a href="https://codepen.io/qwguo88/full/KKdRXLe" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/KKdRXLe</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="grid-area" src="https://codepen.io/qwguo88/embed/KKdRXLe?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/KKdRXLe" rel="external nofollow noopener noreferrer" target="_blank">grid-area</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p><img src="/2019/07/20/CSS3/grid/grid-area_1.png" alt="image"></p><p>上图是通过设置子项的<code>grid-area: area-name</code>，可以看出第一个子项占据了3列得区域也就是<code>head</code>区域，第二个子项占据第2行的第1列区域<code>body-content</code>，第三个子项占据第2行的后2列<code>body-right</code>，最后一个子项占据第3行的3列区域<code>foot</code>。</p><p><img src="/2019/07/20/CSS3/grid/grid-area_2.png" alt="image"></p><p>这里我们重点说一下使用第二种方式，图上可以看出第一项子项使用<code>grid-area: row-two-start / col-one-start /row-three-end /col-three-end;</code>，虽然网格容器定义了区域，但是第一项还是按照<code>grid-row</code>和<code>grid-column</code>的形式占据区域。</p><h3 id="单项对齐方式"><a href="#单项对齐方式" class="headerlink" title="单项对齐方式"></a>单项对齐方式</h3><h4 id="justify-self"><a href="#justify-self" class="headerlink" title="justify-self"></a>justify-self</h4><blockquote><p>用于单独设置子项的水平对齐方式</p></blockquote><p><strong>案例展示：</strong><a href="https://codepen.io/qwguo88/full/PoPeOXB" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/PoPeOXB</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="grid-justify-self" src="https://codepen.io/qwguo88/embed/PoPeOXB?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/PoPeOXB" rel="external nofollow noopener noreferrer" target="_blank">grid-justify-self</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p><img src="/2019/07/20/CSS3/grid/justify-self.png" alt="image"></p><p>上图展示了各取值的展示效果。</p><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><blockquote><p>用于单独设置子项的垂直对齐方式</p></blockquote><p><strong>案例展示：</strong><a href="https://codepen.io/qwguo88/full/gOazoLZ" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/gOazoLZ</a></p><iframe height="500" style="width: 100%;" scrolling="no" title="grid-align-self" src="https://codepen.io/qwguo88/embed/gOazoLZ?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/gOazoLZ" rel="external nofollow noopener noreferrer" target="_blank">grid-align-self</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><p><img src="/2019/07/20/CSS3/grid/align-self.png" alt="image"></p><p>上图展示了各取值的展示效果。</p><h4 id="place-self"><a href="#place-self" class="headerlink" title="place-self"></a>place-self</h4><blockquote><p><code>place-self</code>属性是<code>align-self</code>和<code>justify-self</code>缩写形式。第一个值指<code>align-self</code>，第二个值指<code>justify-self</code>。如果第二个值不存在，则第一个值也将用于该值。两个值之间用空格分开。</p></blockquote><p><strong>案例展示：</strong><a href="https://codepen.io/qwguo88/full/GRpdyEP" rel="external nofollow noopener noreferrer" target="_blank">https://codepen.io/qwguo88/full/GRpdyEP</a></p><p><iframe height="500" style="width: 100%;" scrolling="no" title="grid-place-self" src="https://codepen.io/qwguo88/embed/GRpdyEP?height=500&theme-id=30742&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/qwguo88/pen/GRpdyEP" rel="external nofollow noopener noreferrer" target="_blank">grid-place-self</a> by qwguo<br>  (<a href="https://codepen.io/qwguo88" rel="external nofollow noopener noreferrer" target="_blank">@qwguo88</a>) on <a href="https://codepen.io" rel="external nofollow noopener noreferrer" target="_blank">CodePen</a>.<br></iframe><br><img src="/2019/07/20/CSS3/grid/place-self.png" alt="image"></p><p>上图展示了部分值得展示效果。</p><h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><h3 id="grid可视化在线生成代码"><a href="#grid可视化在线生成代码" class="headerlink" title="grid可视化在线生成代码"></a>grid可视化在线生成代码</h3><ol><li>可以拖动增加删除网格：<a href="https://grid.layoutit.com/" rel="external nofollow noopener noreferrer" target="_blank">https://grid.layoutit.com/</a></li></ol><h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><ol><li><a href="https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/" rel="external nofollow noopener noreferrer" target="_blank">https://www.zhangxinxu.com/wordpress/2018/11/display-grid-css-css3/</a></li><li><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
            <tag> grid </tag>
            
            <tag> 网格布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ScrollifyJs</title>
      <link href="/2019/02/14/ScrollifyJs/"/>
      <url>/2019/02/14/ScrollifyJs/</url>
      
        <content type="html"><![CDATA[<h2 id="jQuery-Scrollify"><a href="#jQuery-Scrollify" class="headerlink" title="jQuery Scrollify"></a>jQuery Scrollify</h2><p>是一个jQuery插件，他可以实现整屏滚动。</p><table><thead><tr><th>参数</th><th style="text-align:center">说明</th><th style="text-align:center">默认值</th></tr></thead><tbody><tr><td>host</td><td style="text-align:center">远程主机的地址</td><td style="text-align:center"></td></tr><tr><td>user</td><td style="text-align:center">使用者名称</td><td style="text-align:center"></td></tr><tr><td>root</td><td style="text-align:center">远程主机的根目录</td><td style="text-align:center"></td></tr><tr><td>port</td><td style="text-align:center">端口</td><td style="text-align:center">22</td></tr><tr><td>delete</td><td style="text-align:center">删除远程主机上的旧文件</td><td style="text-align:center">true</td></tr><tr><td>verbose</td><td style="text-align:center">显示调试信息</td><td style="text-align:center">true</td></tr><tr><td>ignore_errors</td><td style="text-align:center">忽略错误</td><td style="text-align:center">false</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JQuery </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
